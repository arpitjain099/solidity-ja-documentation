# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2023, The Solidity Authors
# This file is distributed under the same license as the Solidity package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Solidity 0.8.20\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-03-18 04:40+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja_JP\n"
"Language-Team: ja_JP <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../introduction-to-smart-contracts.rst:3 de9bc2df78334bf18f4631232cbc900a
msgid "Introduction to Smart Contracts"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:9 32bcd48706484098a117923c2eb9fc2b
msgid "A Simple Smart Contract"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:11
#: aa363b37c9d64b098dc8f1069ca64c2e
msgid ""
"Let us begin with a basic example that sets the value of a variable and "
"exposes it for other contracts to access. It is fine if you do not "
"understand everything right now, we will go into more details later."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:16
#: f0a3a747aabd4651b8d610d8a33a8cac
msgid "Storage Example"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:35
#: f1b51ce4c01d427d8614ad6cd727d495
msgid ""
"The first line tells you that the source code is licensed under the GPL "
"version 3.0. Machine-readable license specifiers are important in a "
"setting where publishing the source code is the default."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:39
#: ea1288422326430ea509d4915e9ad9d5
msgid ""
"The next line specifies that the source code is written for Solidity "
"version 0.4.16, or a newer version of the language up to, but not "
"including version 0.9.0. This is to ensure that the contract is not "
"compilable with a new (breaking) compiler version, where it could behave "
"differently. :ref:`Pragmas<pragma>` are common instructions for compilers"
" about how to treat the source code (e.g. `pragma once "
"<https://en.wikipedia.org/wiki/Pragma_once>`_)."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:45
#: 23394dbe0bda43859c0859b9fd80839b
msgid ""
"A contract in the sense of Solidity is a collection of code (its "
"*functions*) and data (its *state*) that resides at a specific address on"
" the Ethereum blockchain. The line ``uint storedData;`` declares a state "
"variable called ``storedData`` of type ``uint`` (*u*\\nsigned *int*\\eger"
" of *256* bits). You can think of it as a single slot in a database that "
"you can query and alter by calling functions of the code that manages the"
" database. In this example, the contract defines the functions ``set`` "
"and ``get`` that can be used to modify or retrieve the value of the "
"variable."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:54
#: e6cde6efc0924af39c28dcd2e40446e9
msgid ""
"To access a member (like a state variable) of the current contract, you "
"do not typically add the ``this.`` prefix, you just access it directly "
"via its name. Unlike in some other languages, omitting it is not just a "
"matter of style, it results in a completely different way to access the "
"member, but more on this later."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:59
#: 85a074a8d8e6412da10aa310bf942b8e
msgid ""
"This contract does not do much yet apart from (due to the infrastructure "
"built by Ethereum) allowing anyone to store a single number that is "
"accessible by anyone in the world without a (feasible) way to prevent you"
" from publishing this number. Anyone could call ``set`` again with a "
"different value and overwrite your number, but the number is still stored"
" in the history of the blockchain. Later, you will see how you can impose"
" access restrictions so that only you can alter the number."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:68
#: 2bbd735a23284ee4a4348843beebbb86
msgid ""
"Be careful with using Unicode text, as similar looking (or even "
"identical) characters can have different code points and as such are "
"encoded as a different byte array."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:72
#: 32717015d99f47408478e42e99a5bef2
msgid ""
"All identifiers (contract names, function names and variable names) are "
"restricted to the ASCII character set. It is possible to store UTF-8 "
"encoded data in string variables."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:78
#: 5bb362e4de2445d186c97385d3c5eedb
msgid "Subcurrency Example"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:80
#: 575167b6397442388e266783a382c6c8
msgid ""
"The following contract implements the simplest form of a cryptocurrency. "
"The contract allows only its creator to create new coins (different "
"issuance schemes are possible). Anyone can send coins to each other "
"without a need for registering with a username and password, all you need"
" is an Ethereum keypair."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:133
#: b0e0aac564f64348948916e6bdeeb20c
msgid ""
"This contract introduces some new concepts, let us go through them one by"
" one."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:135
#: 1cf0e61f0671451eae326165066f6e6d
msgid ""
"The line ``address public minter;`` declares a state variable of type "
":ref:`address<address>`. The ``address`` type is a 160-bit value that "
"does not allow any arithmetic operations. It is suitable for storing "
"addresses of contracts, or a hash of the public half of a keypair "
"belonging to :ref:`external accounts<accounts>`."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:140
#: 12a7dcda47dd4d7eb415dcf6b397f63c
msgid ""
"The keyword ``public`` automatically generates a function that allows you"
" to access the current value of the state variable from outside of the "
"contract. Without this keyword, other contracts have no way to access the"
" variable. The code of the function generated by the compiler is "
"equivalent to the following (ignore ``external`` and ``view`` for now):"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:149
#: b14dc4e2e74348f096cd50ce06e53663
msgid ""
"You could add a function like the above yourself, but you would have a "
"function and state variable with the same name. You do not need to do "
"this, the compiler figures it out for you."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:154
#: 8f7cc7e17f584d398fcd9c5eef4df0c6
msgid ""
"The next line, ``mapping(address => uint) public balances;`` also creates"
" a public state variable, but it is a more complex datatype. The "
":ref:`mapping <mapping-types>` type maps addresses to :ref:`unsigned "
"integers <integers>`."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:158
#: 5848dbbd7a0c40a7ac1c5267e0422177
msgid ""
"Mappings can be seen as `hash tables "
"<https://en.wikipedia.org/wiki/Hash_table>`_ which are virtually "
"initialised such that every possible key exists from the start and is "
"mapped to a value whose byte-representation is all zeros. However, it is "
"neither possible to obtain a list of all keys of a mapping, nor a list of"
" all values. Record what you added to the mapping, or use it in a context"
" where this is not needed. Or even better, keep a list, or use a more "
"suitable data type."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:165
#: 4cfd8a9fa1f84e6b855357203b225792
msgid ""
"The :ref:`getter function<getter-functions>` created by the ``public`` "
"keyword is more complex in the case of a mapping. It looks like the "
"following:"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:175
#: 78f6fa08d0ea41f380693c1cb24b43e6
msgid "You can use this function to query the balance of a single account."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:179
#: a8a4833c300a4b3a90753e9ddf654b0c
msgid ""
"The line ``event Sent(address from, address to, uint amount);`` declares "
"an :ref:`\"event\" <events>`, which is emitted in the last line of the "
"function ``send``. Ethereum clients such as web applications can listen "
"for these events emitted on the blockchain without much cost. As soon as "
"it is emitted, the listener receives the arguments ``from``, ``to`` and "
"``amount``, which makes it possible to track transactions."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:187
#: 94ba725f5e1b4118a185b92e7a4c679c
msgid ""
"To listen for this event, you could use the following JavaScript code, "
"which uses `web3.js <https://github.com/web3/web3.js/>`_ to create the "
"``Coin`` contract object, and any user interface calls the automatically "
"generated ``balances`` function from above:"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:206
#: 05bf4bad37f04652b3d43a1b453c6b5b
msgid ""
"The :ref:`constructor<constructor>` is a special function that is "
"executed during the creation of the contract and cannot be called "
"afterwards. In this case, it permanently stores the address of the person"
" creating the contract. The ``msg`` variable (together with ``tx`` and "
"``block``) is a :ref:`special global variable <special-variables-"
"functions>` that contains properties which allow access to the "
"blockchain. ``msg.sender`` is always the address where the current "
"(external) function call came from."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:213
#: c24e3bb6ea8b491f9af38d9d49a7f787
msgid ""
"The functions that make up the contract, and that users and contracts can"
" call are ``mint`` and ``send``."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:215
#: f2d6c54922894598bc8fbb44f78f32fd
msgid ""
"The ``mint`` function sends an amount of newly created coins to another "
"address. The :ref:`require <assert-and-require>` function call defines "
"conditions that reverts all changes if not met. In this example, "
"``require(msg.sender == minter);`` ensures that only the creator of the "
"contract can call ``mint``. In general, the creator can mint as many "
"tokens as they like, but at some point, this will lead to a phenomenon "
"called \"overflow\". Note that because of the default :ref:`Checked "
"arithmetic <unchecked>`, the transaction would revert if the expression "
"``balances[receiver] += amount;`` overflows, i.e., when "
"``balances[receiver] + amount`` in arbitrary precision arithmetic is "
"larger than the maximum value of ``uint`` (``2**256 - 1``). This is also "
"true for the statement ``balances[receiver] += amount;`` in the function "
"``send``."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:225
#: dc0690e1e5c44b7e83c4f9cc5471f16c
msgid ""
":ref:`Errors <errors>` allow you to provide more information to the "
"caller about why a condition or operation failed. Errors are used "
"together with the :ref:`revert statement <revert-statement>`. The "
"``revert`` statement unconditionally aborts and reverts all changes "
"similar to the ``require`` function, but it also allows you to provide "
"the name of an error and additional data which will be supplied to the "
"caller (and eventually to the front-end application or block explorer) so"
" that a failure can more easily be debugged or reacted upon."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:233
#: 218b53f713514da98255f8d54098740b
msgid ""
"The ``send`` function can be used by anyone (who already has some of "
"these coins) to send coins to anyone else. If the sender does not have "
"enough coins to send, the ``if`` condition evaluates to true. As a "
"result, the ``revert`` will cause the operation to fail while providing "
"the sender with error details using the ``InsufficientBalance`` error."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:239
#: 5f05c677970d4ea1b98bc9cb2ed5c426
msgid ""
"If you use this contract to send coins to an address, you will not see "
"anything when you look at that address on a blockchain explorer, because "
"the record that you sent coins and the changed balances are only stored "
"in the data storage of this particular coin contract. By using events, "
"you can create a \"blockchain explorer\" that tracks transactions and "
"balances of your new coin, but you have to inspect the coin contract "
"address and not the addresses of the coin owners."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:252
#: 440622629b90443799477ccdf8ae1418
msgid "Blockchain Basics"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:254
#: 0132938e57c245eca4f516792349f233
msgid ""
"Blockchains as a concept are not too hard to understand for programmers. "
"The reason is that most of the complications (mining, `hashing "
"<https://en.wikipedia.org/wiki/Cryptographic_hash_function>`_, `elliptic-"
"curve cryptography "
"<https://en.wikipedia.org/wiki/Elliptic_curve_cryptography>`_, `peer-to-"
"peer networks <https://en.wikipedia.org/wiki/Peer-to-peer>`_, etc.) are "
"just there to provide a certain set of features and promises for the "
"platform. Once you accept these features as given, you do not have to "
"worry about the underlying technology - or do you have to know how "
"Amazon's AWS works internally in order to use it?"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:265
#: ../../introduction-to-smart-contracts.rst:368
#: 252ea613245d4aef97a6d306f72d892c 2ae69488ddfa4885b53e52c4fd1da02f
msgid "Transactions"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:267
#: 463b8f5887fe4556a479ad7e5ebf713b
msgid ""
"A blockchain is a globally shared, transactional database. This means "
"that everyone can read entries in the database just by participating in "
"the network. If you want to change something in the database, you have to"
" create a so-called transaction which has to be accepted by all others. "
"The word transaction implies that the change you want to make (assume you"
" want to change two values at the same time) is either not done at all or"
" completely applied. Furthermore, while your transaction is being applied"
" to the database, no other transaction can alter it."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:275
#: c8ff0f9de67f4607a94e73378632da00
msgid ""
"As an example, imagine a table that lists the balances of all accounts in"
" an electronic currency. If a transfer from one account to another is "
"requested, the transactional nature of the database ensures that if the "
"amount is subtracted from one account, it is always added to the other "
"account. If due to whatever reason, adding the amount to the target "
"account is not possible, the source account is also not modified."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:282
#: 86e2e1cb5114499197783e26d0e9448b
msgid ""
"Furthermore, a transaction is always cryptographically signed by the "
"sender (creator). This makes it straightforward to guard access to "
"specific modifications of the database. In the example of the electronic "
"currency, a simple check ensures that only the person holding the keys to"
" the account can transfer money from it."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:290
#: 1509a63d948f480b859ce8133d6d32de
msgid "Blocks"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:292
#: 1902564001b140dd8b0ce568497a6849
msgid ""
"One major obstacle to overcome is what (in Bitcoin terms) is called a "
"\"double-spend attack\": What happens if two transactions exist in the "
"network that both want to empty an account? Only one of the transactions "
"can be valid, typically the one that is accepted first. The problem is "
"that \"first\" is not an objective term in a peer-to-peer network."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:297
#: 2234c32cb6de4983ad4b4afe4ad85ea3
msgid ""
"The abstract answer to this is that you do not have to care. A globally "
"accepted order of the transactions will be selected for you, solving the "
"conflict. The transactions will be bundled into what is called a "
"\"block\" and then they will be executed and distributed among all "
"participating nodes. If two transactions contradict each other, the one "
"that ends up being second will be rejected and not become part of the "
"block."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:303
#: 97698592eb8247459b47c1ec7079797e
msgid ""
"These blocks form a linear sequence in time, and that is where the word "
"\"blockchain\" derives from. Blocks are added to the chain at regular "
"intervals, although these intervals may be subject to change in the "
"future. For the most up-to-date information, it is recommended to monitor"
" the network, for example, on `Etherscan "
"<https://etherscan.io/chart/blocktime>`_."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:307
#: 5b51cc16f4be4bc390b5093b96b09b0a
msgid ""
"As part of the \"order selection mechanism\" (which is called \"mining\")"
" it may happen that blocks are reverted from time to time, but only at "
"the \"tip\" of the chain. The more blocks are added on top of a "
"particular block, the less likely this block will be reverted. So it "
"might be that your transactions are reverted and even removed from the "
"blockchain, but the longer you wait, the less likely it will be."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:314
#: dc77afec5aab4d7faae8b7fa45d77ed7
msgid ""
"Transactions are not guaranteed to be included in the next block or any "
"specific future block, since it is not up to the submitter of a "
"transaction, but up to the miners to determine in which block the "
"transaction is included."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:317
#: 46e9c1ab400247e2bb715d0b059a68ce
msgid ""
"If you want to schedule future calls of your contract, you can use a "
"smart contract automation tool or an oracle service."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:326
#: 86ab61cc07f64146b5d5878866646c53
msgid "The Ethereum Virtual Machine"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:329
#: 1d35b4acfa82436db2d0fc4a9e010e16
msgid "Overview"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:331
#: 5339425e9767455599ecf577924982d2
msgid ""
"The Ethereum Virtual Machine or EVM is the runtime environment for smart "
"contracts in Ethereum. It is not only sandboxed but actually completely "
"isolated, which means that code running inside the EVM has no access to "
"network, filesystem or other processes. Smart contracts even have limited"
" access to other smart contracts."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:342
#: fd10922339e7453fb6d704fdad5d1ec8
msgid "Accounts"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:344
#: 7ea0bbc3ced84809a54ba5e73d4b3683
msgid ""
"There are two kinds of accounts in Ethereum which share the same address "
"space: **External accounts** that are controlled by public-private key "
"pairs (i.e. humans) and **contract accounts** which are controlled by the"
" code stored together with the account."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:349
#: 1103e42acfa34061a7ed7bcc43d5beff
msgid ""
"The address of an external account is determined from the public key "
"while the address of a contract is determined at the time the contract is"
" created (it is derived from the creator address and the number of "
"transactions sent from that address, the so-called \"nonce\")."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:355
#: 234f8f0217c64fc489feee9f9812ac4d
msgid ""
"Regardless of whether or not the account stores code, the two types are "
"treated equally by the EVM."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:358
#: 8af6e89f7c184ca4a69d92918f87e6f4
msgid ""
"Every account has a persistent key-value store mapping 256-bit words to "
"256-bit words called **storage**."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:361
#: 8cfa594c71a444a2926a81c84485a23f
msgid ""
"Furthermore, every account has a **balance** in Ether (in \"Wei\" to be "
"exact, ``1 ether`` is ``10**18 wei``) which can be modified by sending "
"transactions that include Ether."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:370
#: 6809551f71a445de8ade07381da6174f
msgid ""
"A transaction is a message that is sent from one account to another "
"account (which might be the same or empty, see below). It can include "
"binary data (which is called \"payload\") and Ether."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:374
#: 628bf37ab9f64ca189772dab715a600e
msgid ""
"If the target account contains code, that code is executed and the "
"payload is provided as input data."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:377
#: 16cc9469fe3944bb90d21a5460fd6825
msgid ""
"If the target account is not set (the transaction does not have a "
"recipient or the recipient is set to ``null``), the transaction creates a"
" **new contract**. As already mentioned, the address of that contract is "
"not the zero address but an address derived from the sender and its "
"number of transactions sent (the \"nonce\"). The payload of such a "
"contract creation transaction is taken to be EVM bytecode and executed. "
"The output data of this execution is permanently stored as the code of "
"the contract. This means that in order to create a contract, you do not "
"send the actual code of the contract, but in fact code that returns that "
"code when executed."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:391
#: 7ec95f97884943e59dfb0e81962036b2
msgid ""
"While a contract is being created, its code is still empty. Because of "
"that, you should not call back into the contract under construction until"
" its constructor has finished executing."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:399
#: 6e7ee751ff8c482d937c44fc34c09d38
msgid "Gas"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:401
#: 03c452aac47f46c89cb6a9dca093af91
msgid ""
"Upon creation, each transaction is charged with a certain amount of "
"**gas** that has to be paid for by the originator of the transaction "
"(``tx.origin``). While the EVM executes the transaction, the gas is "
"gradually depleted according to specific rules. If the gas is used up at "
"any point (i.e. it would be negative), an out-of-gas exception is "
"triggered, which ends execution and reverts all modifications made to the"
" state in the current call frame."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:409
#: d9a0b238be314059b7372baae79f160b
msgid ""
"This mechanism incentivizes economical use of EVM execution time and also"
" compensates EVM executors (i.e. miners / stakers) for their work. Since "
"each block has a maximum amount of gas, it also limits the amount of work"
" needed to validate a block."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:414
#: 8e6c648b6ded45fb835755210075407c
msgid ""
"The **gas price** is a value set by the originator of the transaction, "
"who has to pay ``gas_price * gas`` up front to the EVM executor. If some "
"gas is left after execution, it is refunded to the transaction "
"originator. In case of an exception that reverts changes, already used up"
" gas is not refunded."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:419
#: ba8c1dd658b248cea960d79df6aaf7ce
msgid ""
"Since EVM executors can choose to include a transaction or not, "
"transaction senders cannot abuse the system by setting a low gas price."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:425
#: 03fefdde9a8b4bb9a7792b060d1bf100
msgid "Storage, Memory and the Stack"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:427
#: 14061fb5b18b466baf790308382ee2eb
msgid ""
"The Ethereum Virtual Machine has three areas where it can store data: "
"storage, memory and the stack."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:430
#: 87a1693436364809918318d18874aa7e
msgid ""
"Each account has a data area called **storage**, which is persistent "
"between function calls and transactions. Storage is a key-value store "
"that maps 256-bit words to 256-bit words. It is not possible to enumerate"
" storage from within a contract, it is comparatively costly to read, and "
"even more to initialise and modify storage. Because of this cost, you "
"should minimize what you store in persistent storage to what the contract"
" needs to run. Store data like derived calculations, caching, and "
"aggregates outside of the contract. A contract can neither read nor write"
" to any storage apart from its own."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:439
#: 2aee4a878d74402d8286df46344ac4bb
msgid ""
"The second data area is called **memory**, of which a contract obtains a "
"freshly cleared instance for each message call. Memory is linear and can "
"be addressed at byte level, but reads are limited to a width of 256 bits,"
" while writes can be either 8 bits or 256 bits wide. Memory is expanded "
"by a word (256-bit), when accessing (either reading or writing) a "
"previously untouched memory word (i.e. any offset within a word). At the "
"time of expansion, the cost in gas must be paid. Memory is more costly "
"the larger it grows (it scales quadratically)."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:447
#: ebfad9bbab694a5ead2abb7b732af895
msgid ""
"The EVM is not a register machine but a stack machine, so all "
"computations are performed on a data area called the **stack**. It has a "
"maximum size of 1024 elements and contains words of 256 bits. Access to "
"the stack is limited to the top end in the following way: It is possible "
"to copy one of the topmost 16 elements to the top of the stack or swap "
"the topmost element with one of the 16 elements below it. All other "
"operations take the topmost two (or one, or more, depending on the "
"operation) elements from the stack and push the result onto the stack. Of"
" course it is possible to move stack elements to storage or memory in "
"order to get deeper access to the stack, but it is not possible to just "
"access arbitrary elements deeper in the stack without first removing the "
"top of the stack."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:464
#: 2b4d64df64db401a92b5f043c16cd9d0
msgid "Instruction Set"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:466
#: c41e08f2cd124dc3b9a14f6aff71acb8
msgid ""
"The instruction set of the EVM is kept minimal in order to avoid "
"incorrect or inconsistent implementations which could cause consensus "
"problems. All instructions operate on the basic data type, 256-bit words "
"or on slices of memory (or other byte arrays). The usual arithmetic, bit,"
" logical and comparison operations are present. Conditional and "
"unconditional jumps are possible. Furthermore, contracts can access "
"relevant properties of the current block like its number and timestamp."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:475
#: 1e04d4ef88524060b01060dbe2b1772b
msgid ""
"For a complete list, please see the :ref:`list of opcodes <opcodes>` as "
"part of the inline assembly documentation."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:481
#: 2e5f57512d144d9b82e1d1b6942debec
msgid "Message Calls"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:483
#: 50faa3384c65425ea3d9bacbf7db2dcc
msgid ""
"Contracts can call other contracts or send Ether to non-contract accounts"
" by the means of message calls. Message calls are similar to "
"transactions, in that they have a source, a target, data payload, Ether, "
"gas and return data. In fact, every transaction consists of a top-level "
"message call which in turn can create further message calls."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:489
#: 58f05798d955465f8353a61adefe0849
msgid ""
"A contract can decide how much of its remaining **gas** should be sent "
"with the inner message call and how much it wants to retain. If an out-"
"of-gas exception happens in the inner call (or any other exception), this"
" will be signaled by an error value put onto the stack. In this case, "
"only the gas sent together with the call is used up. In Solidity, the "
"calling contract causes a manual exception by default in such situations,"
" so that exceptions \"bubble up\" the call stack."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:497
#: 796529813cb64010a1faf46099bfa32e
msgid ""
"As already said, the called contract (which can be the same as the "
"caller) will receive a freshly cleared instance of memory and has access "
"to the call payload - which will be provided in a separate area called "
"the **calldata**. After it has finished execution, it can return data "
"which will be stored at a location in the caller's memory preallocated by"
" the caller. All such calls are fully synchronous."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:504
#: da0c862c6f334114924e809f2b4bb97e
msgid ""
"Calls are **limited** to a depth of 1024, which means that for more "
"complex operations, loops should be preferred over recursive calls. "
"Furthermore, only 63/64th of the gas can be forwarded in a message call, "
"which causes a depth limit of a little less than 1000 in practice."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:512
#: e3694e3f01e3490dbc69a5749cbd9806
msgid "Delegatecall and Libraries"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:514
#: 22a687a2ed14473cbe967ad2d1213aec
msgid ""
"There exists a special variant of a message call, named **delegatecall** "
"which is identical to a message call apart from the fact that the code at"
" the target address is executed in the context (i.e. at the address) of "
"the calling contract and ``msg.sender`` and ``msg.value`` do not change "
"their values."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:519
#: da1ba4296ba74ed79c4bfe45cd789df9
msgid ""
"This means that a contract can dynamically load code from a different "
"address at runtime. Storage, current address and balance still refer to "
"the calling contract, only the code is taken from the called address."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:523
#: 0c90209e6e174009bf39dabc4fc3c02a
msgid ""
"This makes it possible to implement the \"library\" feature in Solidity: "
"Reusable library code that can be applied to a contract's storage, e.g. "
"in order to implement a complex data structure."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:530
#: 3ef3512877104c0fa803115e92c799f3
msgid "Logs"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:532
#: 4c3f898dc2954673a19a73ec7e1cb4ad
msgid ""
"It is possible to store data in a specially indexed data structure that "
"maps all the way up to the block level. This feature called **logs** is "
"used by Solidity in order to implement :ref:`events <events>`. Contracts "
"cannot access log data after it has been created, but they can be "
"efficiently accessed from outside the blockchain. Since some part of the "
"log data is stored in `bloom filters "
"<https://en.wikipedia.org/wiki/Bloom_filter>`_, it is possible to search "
"for this data in an efficient and cryptographically secure way, so "
"network peers that do not download the whole blockchain (so-called "
"\"light clients\") can still find these logs."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:545
#: 7018cb26515e4e6bb1f3ffe0e6101fb1
msgid "Create"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:547
#: 5217716b9ae943fa91dde698b1165e98
msgid ""
"Contracts can even create other contracts using a special opcode (i.e. "
"they do not simply call the zero address as a transaction would). The "
"only difference between these **create calls** and normal message calls "
"is that the payload data is executed and the result stored as code and "
"the caller / creator receives the address of the new contract on the "
"stack."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:556
#: afa480bb282b4e21882c93136999618d
msgid "Deactivate and Self-destruct"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:558
#: c2e01db480994db3b5aeb94f5fe452a3
msgid ""
"The only way to remove code from the blockchain is when a contract at "
"that address performs the ``selfdestruct`` operation. The remaining Ether"
" stored at that address is sent to a designated target and then the "
"storage and code is removed from the state. Removing the contract in "
"theory sounds like a good idea, but it is potentially dangerous, as if "
"someone sends Ether to removed contracts, the Ether is forever lost."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:566
#: 0cf06ace10594b8482147949049f651a
msgid ""
"From version 0.8.18 and up, the use of ``selfdestruct`` in both Solidity "
"and Yul will trigger a deprecation warning, since the ``SELFDESTRUCT`` "
"opcode will eventually undergo breaking changes in behaviour as stated in"
" `EIP-6049 <https://eips.ethereum.org/EIPS/eip-6049>`_."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:571
#: f0dfbf8f68d34a678c50b7b3533672f1
msgid ""
"Even if a contract is removed by ``selfdestruct``, it is still part of "
"the history of the blockchain and probably retained by most Ethereum "
"nodes. So using ``selfdestruct`` is not the same as deleting data from a "
"hard disk."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:576
#: a241fd18d95240309b601aa3855dec7a
msgid ""
"Even if a contract's code does not contain a call to ``selfdestruct``, it"
" can still perform that operation using ``delegatecall`` or ``callcode``."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:579
#: afbeb74fae2e42f48d70873e39444f7a
msgid ""
"If you want to deactivate your contracts, you should instead **disable** "
"them by changing some internal state which causes all functions to "
"revert. This makes it impossible to use the contract, as it returns Ether"
" immediately."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:589
#: f06d546b143446569413c07bb7ef7909
msgid "Precompiled Contracts"
msgstr ""

#: ../../introduction-to-smart-contracts.rst:591
#: 371a0a0ab0d2435d8e810eefad6f0a29
msgid ""
"There is a small set of contract addresses that are special: The address "
"range between ``1`` and (including) ``8`` contains \"precompiled "
"contracts\" that can be called as any other contract but their behaviour "
"(and their gas consumption) is not defined by EVM code stored at that "
"address (they do not contain code) but instead is implemented in the EVM "
"execution environment itself."
msgstr ""

#: ../../introduction-to-smart-contracts.rst:598
#: eb605548d25a4574804476c05fd64189
msgid ""
"Different EVM-compatible chains might use a different set of precompiled "
"contracts. It might also be possible that new precompiled contracts are "
"added to the Ethereum main chain in the future, but you can reasonably "
"expect them to always be in the range between ``1`` and ``0xffff`` "
"(inclusive)."
msgstr ""

