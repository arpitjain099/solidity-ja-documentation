# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2023, The Solidity Authors
# This file is distributed under the same license as the Solidity package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Solidity 0.8.20\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-03-18 04:40+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja_JP\n"
"Language-Team: ja_JP <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../control-structures.rst:3 d1c12e199033411fa870bb44d2bef38b
msgid "Expressions and Control Structures"
msgstr ""

#: ../../control-structures.rst:11 1c44f20edeb84fe797dd3c455ab356cb
msgid "Control Structures"
msgstr ""

#: ../../control-structures.rst:13 b762ba2cea0b44f9b269062c3c6d4c24
msgid ""
"Most of the control structures known from curly-braces languages are "
"available in Solidity:"
msgstr ""

#: ../../control-structures.rst:15 b164de03966444aa9e67052731ccd711
msgid ""
"There is: ``if``, ``else``, ``while``, ``do``, ``for``, ``break``, "
"``continue``, ``return``, with the usual semantics known from C or "
"JavaScript."
msgstr ""

#: ../../control-structures.rst:18 8acef7c9220c43318a898878bb95e30b
msgid ""
"Solidity also supports exception handling in the form of "
"``try``/``catch``-statements, but only for :ref:`external function calls "
"<external-function-calls>` and contract creation calls. Errors can be "
"created using the :ref:`revert statement <revert-statement>`."
msgstr ""

#: ../../control-structures.rst:22 8eed764b98d1485cb98dcf550d8dcff0
msgid ""
"Parentheses can *not* be omitted for conditionals, but curly braces can "
"be omitted around single-statement bodies."
msgstr ""

#: ../../control-structures.rst:25 9f3c0c9d42fe4aa1b94ee1e0ec7f212b
msgid ""
"Note that there is no type conversion from non-boolean to boolean types "
"as there is in C and JavaScript, so ``if (1) { ... }`` is *not* valid "
"Solidity."
msgstr ""

#: ../../control-structures.rst:34 7abd69eec51f45a28f9dc87642eba31a
msgid "Function Calls"
msgstr ""

#: ../../control-structures.rst:39 36211fa674924ecfb86a9b0298d239d4
msgid "Internal Function Calls"
msgstr ""

#: ../../control-structures.rst:41 f8c1725b97c842ae843d238dfce2656e
msgid ""
"Functions of the current contract can be called directly "
"(\"internally\"), also recursively, as seen in this nonsensical example:"
msgstr ""

#: ../../control-structures.rst:55 6a46e23881174d7fbc1a4958edf0628d
msgid ""
"These function calls are translated into simple jumps inside the EVM. "
"This has the effect that the current memory is not cleared, i.e. passing "
"memory references to internally-called functions is very efficient. Only "
"functions of the same contract instance can be called internally."
msgstr ""

#: ../../control-structures.rst:60 efbf5168a9fd4301bfe10a125598fb53
msgid ""
"You should still avoid excessive recursion, as every internal function "
"call uses up at least one stack slot and there are only 1024 slots "
"available."
msgstr ""

#: ../../control-structures.rst:66 13cf8488e1a9440d82452b2f4a683241
msgid "External Function Calls"
msgstr ""

#: ../../control-structures.rst:68 c316fcd21aaf4cfcac5ec4bd983a1a45
msgid ""
"Functions can also be called using the ``this.g(8);`` and ``c.g(2);`` "
"notation, where ``c`` is a contract instance and ``g`` is a function "
"belonging to ``c``. Calling the function ``g`` via either way results in "
"it being called \"externally\", using a message call and not directly via"
" jumps. Please note that function calls on ``this`` cannot be used in the"
" constructor, as the actual contract has not been created yet."
msgstr ""

#: ../../control-structures.rst:75 34a33dce4e0b427e912df482c7384e5d
msgid ""
"Functions of other contracts have to be called externally. For an "
"external call, all function arguments have to be copied to memory."
msgstr ""

#: ../../control-structures.rst:79 d2339967a7294a95916e0fc36fc803b7
msgid ""
"A function call from one contract to another does not create its own "
"transaction, it is a message call as part of the overall transaction."
msgstr ""

#: ../../control-structures.rst:82 ffc610fe92944128b2fc375eac7edb72
msgid ""
"When calling functions of other contracts, you can specify the amount of "
"Wei or gas sent with the call with the special options ``{value: 10, gas:"
" 10000}``. Note that it is discouraged to specify gas values explicitly, "
"since the gas costs of opcodes can change in the future. Any Wei you send"
" to the contract is added to the total balance of that contract:"
msgstr ""

#: ../../control-structures.rst:103 cd95d9047fd747358dd48648a226c63d
msgid ""
"You need to use the modifier ``payable`` with the ``info`` function "
"because otherwise, the ``value`` option would not be available."
msgstr ""

#: ../../control-structures.rst:107 a3f812f76a134267851d74ec7d391cfe
msgid ""
"Be careful that ``feed.info{value: 10, gas: 800}`` only locally sets the "
"``value`` and amount of ``gas`` sent with the function call, and the "
"parentheses at the end perform the actual call. So ``feed.info{value: 10,"
" gas: 800}`` does not call the function and the ``value`` and ``gas`` "
"settings are lost, only ``feed.info{value: 10, gas: 800}()`` performs the"
" function call."
msgstr ""

#: ../../control-structures.rst:114 8eb9d7d3bd084eaa918c4a0f50dfbbd8
msgid ""
"Due to the fact that the EVM considers a call to a non-existing contract "
"to always succeed, Solidity uses the ``extcodesize`` opcode to check that"
" the contract that is about to be called actually exists (it contains "
"code) and causes an exception if it does not. This check is skipped if "
"the return data will be decoded after the call and thus the ABI decoder "
"will catch the case of a non-existing contract."
msgstr ""

#: ../../control-structures.rst:121 470f8c230dc545428dfec6eaab84dea3
msgid ""
"Note that this check is not performed in case of :ref:`low-level calls "
"<address_related>` which operate on addresses rather than contract "
"instances."
msgstr ""

#: ../../control-structures.rst:125 ab160c3565ef425289c7e2c014f5cb06
msgid ""
"Be careful when using high-level calls to :ref:`precompiled contracts "
"<precompiledContracts>`, since the compiler considers them non-existing "
"according to the above logic even though they execute code and can return"
" data."
msgstr ""

#: ../../control-structures.rst:130 b4a4510e337f428db32c638309633e8b
msgid ""
"Function calls also cause exceptions if the called contract itself throws"
" an exception or goes out of gas."
msgstr ""

#: ../../control-structures.rst:134 cf45900ec6a54e36a46afcb26ccf4e1e
msgid ""
"Any interaction with another contract imposes a potential danger, "
"especially if the source code of the contract is not known in advance. "
"The current contract hands over control to the called contract and that "
"may potentially do just about anything. Even if the called contract "
"inherits from a known parent contract, the inheriting contract is only "
"required to have a correct interface. The implementation of the contract,"
" however, can be completely arbitrary and thus, pose a danger. In "
"addition, be prepared in case it calls into other contracts of your "
"system or even back into the calling contract before the first call "
"returns. This means that the called contract can change state variables "
"of the calling contract via its functions. Write your functions in a way "
"that, for example, calls to external functions happen after any changes "
"to state variables in your contract so your contract is not vulnerable to"
" a reentrancy exploit."
msgstr ""

#: ../../control-structures.rst:149 ac6bfd3be38e4ba6a29c2c20553722a5
msgid ""
"Before Solidity 0.6.2, the recommended way to specify the value and gas "
"was to use ``f.value(x).gas(g)()``. This was deprecated in Solidity 0.6.2"
" and is no longer possible since Solidity 0.7.0."
msgstr ""

#: ../../control-structures.rst:154 84a1de4d9a3b45ab85b22f6d32ef6db7
msgid "Function Calls with Named Parameters"
msgstr ""

#: ../../control-structures.rst:156 ae9a952ad8af432f838afaeff693aa9a
msgid ""
"Function call arguments can be given by name, in any order, if they are "
"enclosed in ``{ }`` as can be seen in the following example. The argument"
" list has to coincide by name with the list of parameters from the "
"function declaration, but can be in arbitrary order."
msgstr ""

#: ../../control-structures.rst:180 da13b31901374abd916799c6da1c8390
msgid "Omitted Names in Function Definitions"
msgstr ""

#: ../../control-structures.rst:182 6c218339691e4e01a14686de4b0bc0ef
msgid ""
"The names of parameters and return values in the function declaration can"
" be omitted. Those items with omitted names will still be present on the "
"stack, but they are inaccessible by name. An omitted return value name "
"can still return a value to the caller by use of the ``return`` "
"statement."
msgstr ""

#: ../../control-structures.rst:205 8bce3cc2889548748d1c11ab8fde53ed
msgid "Creating Contracts via ``new``"
msgstr ""

#: ../../control-structures.rst:207 df229e02b018487db749d8c445e2a2f2
msgid ""
"A contract can create other contracts using the ``new`` keyword. The full"
" code of the contract being created has to be known when the creating "
"contract is compiled so recursive creation-dependencies are not possible."
msgstr ""

#: ../../control-structures.rst:237 29d6e7184d6f4a95a4d8efc0b3541b91
msgid ""
"As seen in the example, it is possible to send Ether while creating an "
"instance of ``D`` using the ``value`` option, but it is not possible to "
"limit the amount of gas. If the creation fails (due to out-of-stack, not "
"enough balance or other problems), an exception is thrown."
msgstr ""

#: ../../control-structures.rst:244 9d0beb54cdde47589f250b0063bd4dfe
msgid "Salted contract creations / create2"
msgstr ""

#: ../../control-structures.rst:246 22d93cc6e8ea4debbb6ee8ae1d1e85db
msgid ""
"When creating a contract, the address of the contract is computed from "
"the address of the creating contract and a counter that is increased with"
" each contract creation."
msgstr ""

#: ../../control-structures.rst:250 3582eb29952346be9f63bfa1e9649250
msgid ""
"If you specify the option ``salt`` (a bytes32 value), then contract "
"creation will use a different mechanism to come up with the address of "
"the new contract:"
msgstr ""

#: ../../control-structures.rst:253 5b6768c65af54ed686a380ec23b9e278
msgid ""
"It will compute the address from the address of the creating contract, "
"the given salt value, the (creation) bytecode of the created contract and"
" the constructor arguments."
msgstr ""

#: ../../control-structures.rst:257 108b3761ed784d32b109773e75b0ddd0
msgid ""
"In particular, the counter (\"nonce\") is not used. This allows for more "
"flexibility in creating contracts: You are able to derive the address of "
"the new contract before it is created. Furthermore, you can rely on this "
"address also in case the creating contracts creates other contracts in "
"the meantime."
msgstr ""

#: ../../control-structures.rst:263 5409dcefae8144b481b11d4dab75b86a
msgid ""
"The main use-case here is contracts that act as judges for off-chain "
"interactions, which only need to be created if there is a dispute."
msgstr ""

#: ../../control-structures.rst:298 9240bfd528e549b6b14f6b22d0177ea7
msgid ""
"There are some peculiarities in relation to salted creation. A contract "
"can be re-created at the same address after having been destroyed. Yet, "
"it is possible for that newly created contract to have a different "
"deployed bytecode even though the creation bytecode has been the same "
"(which is a requirement because otherwise the address would change). This"
" is due to the fact that the constructor can query external state that "
"might have changed between the two creations and incorporate that into "
"the deployed bytecode before it is stored."
msgstr ""

#: ../../control-structures.rst:308 b99c0c8f62f94c6bbbc46ddd748828e5
msgid "Order of Evaluation of Expressions"
msgstr ""

#: ../../control-structures.rst:310 04f6588c9017443e8f3fa14f9fe8f07b
msgid ""
"The evaluation order of expressions is not specified (more formally, the "
"order in which the children of one node in the expression tree are "
"evaluated is not specified, but they are of course evaluated before the "
"node itself). It is only guaranteed that statements are executed in order"
" and short-circuiting for boolean expressions is done."
msgstr ""

#: ../../control-structures.rst:319 38d47590e71b4699aa371efc115011d4
msgid "Assignment"
msgstr ""

#: ../../control-structures.rst:324 b9f5e40c4d81483db93dfd17396b6bc7
msgid "Destructuring Assignments and Returning Multiple Values"
msgstr ""

#: ../../control-structures.rst:326 57ffed3e8d0c491496c0d862cbcfaf06
msgid ""
"Solidity internally allows tuple types, i.e. a list of objects of "
"potentially different types whose number is a constant at compile-time. "
"Those tuples can be used to return multiple values at the same time. "
"These can then either be assigned to newly declared variables or to pre-"
"existing variables (or LValues in general)."
msgstr ""

#: ../../control-structures.rst:332 e892bc4dd82642e7be3820088732d12b
msgid ""
"Tuples are not proper types in Solidity, they can only be used to form "
"syntactic groupings of expressions."
msgstr ""

#: ../../control-structures.rst:358 2a91cf83087b4ff58b5ddd25d2a416ba
msgid ""
"It is not possible to mix variable declarations and non-declaration "
"assignments, i.e. the following is not valid: ``(x, uint y) = (1, 2);``"
msgstr ""

#: ../../control-structures.rst:362 ce30a4b93bda486588547cdc1dad6a93
msgid ""
"Prior to version 0.5.0 it was possible to assign to tuples of smaller "
"size, either filling up on the left or on the right side (which ever was "
"empty). This is now disallowed, so both sides have to have the same "
"number of components."
msgstr ""

#: ../../control-structures.rst:367 3f56bbf15925465d8de125ec54927fb3
msgid ""
"Be careful when assigning to multiple variables at the same time when "
"reference types are involved, because it could lead to unexpected copying"
" behaviour."
msgstr ""

#: ../../control-structures.rst:372 6a6df7ac009c43b9b38a65062bcf2b80
msgid "Complications for Arrays and Structs"
msgstr ""

#: ../../control-structures.rst:374 644f0b25d2cb49569021e8907575a7f6
msgid ""
"The semantics of assignments are more complicated for non-value types "
"like arrays and structs, including ``bytes`` and ``string``, see "
":ref:`Data location and assignment behaviour <data-location-assignment>` "
"for details."
msgstr ""

#: ../../control-structures.rst:377 2bb11abd8f9440dfa96cc2f9f984914e
msgid ""
"In the example below the call to ``g(x)`` has no effect on ``x`` because "
"it creates an independent copy of the storage value in memory. However, "
"``h(x)`` successfully modifies ``x`` because only a reference and not a "
"copy is passed."
msgstr ""

#: ../../control-structures.rst:408 1e388f6b260445d683be8c00d8c864bc
msgid "Scoping and Declarations"
msgstr ""

#: ../../control-structures.rst:410 7f3fcd291243424fb9590181ea340bfa
msgid ""
"A variable which is declared will have an initial default value whose "
"byte-representation is all zeros. The \"default values\" of variables are"
" the typical \"zero-state\" of whatever the type is. For example, the "
"default value for a ``bool`` is ``false``. The default value for the "
"``uint`` or ``int`` types is ``0``. For statically-sized arrays and "
"``bytes1`` to ``bytes32``, each individual element will be initialized to"
" the default value corresponding to its type. For dynamically-sized "
"arrays, ``bytes`` and ``string``, the default value is an empty array or "
"string. For the ``enum`` type, the default value is its first member."
msgstr ""

#: ../../control-structures.rst:422 22bded183b264afcb6860c584b03d613
msgid ""
"Scoping in Solidity follows the widespread scoping rules of C99 (and many"
" other languages): Variables are visible from the point right after their"
" declaration until the end of the smallest ``{ }``-block that contains "
"the declaration. As an exception to this rule, variables declared in the "
"initialization part of a for-loop are only visible until the end of the "
"for-loop."
msgstr ""

#: ../../control-structures.rst:428 53c701da40a944fcb48eceafb97f114b
msgid ""
"Variables that are parameter-like (function parameters, modifier "
"parameters, catch parameters, ...) are visible inside the code block that"
" follows - the body of the function/modifier for a function and modifier "
"parameter and the catch block for a catch parameter."
msgstr ""

#: ../../control-structures.rst:433 5c5cbfd54a0c46c190d0404febf08c8c
msgid ""
"Variables and other items declared outside of a code block, for example "
"functions, contracts, user-defined types, etc., are visible even before "
"they were declared. This means you can use state variables before they "
"are declared and call functions recursively."
msgstr ""

#: ../../control-structures.rst:437 f69375e2edbb43739da957fc26c9e202
msgid ""
"As a consequence, the following examples will compile without warnings, "
"since the two variables have the same name but disjoint scopes."
msgstr ""

#: ../../control-structures.rst:458 054c337d631e446fa01479da09249504
msgid ""
"As a special example of the C99 scoping rules, note that in the "
"following, the first assignment to ``x`` will actually assign the outer "
"and not the inner variable. In any case, you will get a warning about the"
" outer variable being shadowed."
msgstr ""

#: ../../control-structures.rst:479 6facf982b7494e528f2db4b4432723d3
msgid ""
"Before version 0.5.0 Solidity followed the same scoping rules as "
"JavaScript, that is, a variable declared anywhere within a function would"
" be in scope for the entire function, regardless where it was declared. "
"The following example shows a code snippet that used to compile but leads"
" to an error starting from version 0.5.0."
msgstr ""

#: ../../control-structures.rst:502 be375229114f4069bad26c8a447c6901
msgid "Checked or Unchecked Arithmetic"
msgstr ""

#: ../../control-structures.rst:504 3c8b0cf139574ea2a0efd7460fd51780
msgid ""
"An overflow or underflow is the situation where the resulting value of an"
" arithmetic operation, when executed on an unrestricted integer, falls "
"outside the range of the result type."
msgstr ""

#: ../../control-structures.rst:507 5366c377be52433b8f32676d0eaedd93
msgid ""
"Prior to Solidity 0.8.0, arithmetic operations would always wrap in case "
"of under- or overflow leading to widespread use of libraries that "
"introduce additional checks."
msgstr ""

#: ../../control-structures.rst:511 fa4924537b814507916c5e5119a57164
msgid ""
"Since Solidity 0.8.0, all arithmetic operations revert on over- and "
"underflow by default, thus making the use of these libraries unnecessary."
msgstr ""

#: ../../control-structures.rst:514 fba11a8d3dcc4cd98cab2e21ceed671f
msgid "To obtain the previous behaviour, an ``unchecked`` block can be used:"
msgstr ""

#: ../../control-structures.rst:531 583fdab92050486ba39b8640c8febc08
msgid ""
"The call to ``f(2, 3)`` will return ``2**256-1``, while ``g(2, 3)`` will "
"cause a failing assertion."
msgstr ""

#: ../../control-structures.rst:534 09016e622b064d33b035c3574f3c2f7a
msgid ""
"The ``unchecked`` block can be used everywhere inside a block, but not as"
" a replacement for a block. It also cannot be nested."
msgstr ""

#: ../../control-structures.rst:537 58afd65a991d406a837bcf3cc58a9edb
msgid ""
"The setting only affects the statements that are syntactically inside the"
" block. Functions called from within an ``unchecked`` block do not "
"inherit the property."
msgstr ""

#: ../../control-structures.rst:541 01b0d2528e6942a7a726ec541abee769
msgid "To avoid ambiguity, you cannot use ``_;`` inside an ``unchecked`` block."
msgstr ""

#: ../../control-structures.rst:543 9d5dc4526ea64f2181e6266632eb330c
msgid ""
"The following operators will cause a failing assertion on overflow or "
"underflow and will wrap without an error if used inside an unchecked "
"block:"
msgstr ""

#: ../../control-structures.rst:546 eaa725cff6ce42609d183bb57d2bb16c
msgid ""
"``++``, ``--``, ``+``, binary ``-``, unary ``-``, ``*``, ``/``, ``%``, "
"``**``"
msgstr ""

#: ../../control-structures.rst:548 e165f794ad3c401a9e8174f57fd69e2e
msgid "``+=``, ``-=``, ``*=``, ``/=``, ``%=``"
msgstr ""

#: ../../control-structures.rst:551 4d2c92a61aca4eeebe301ee16d6e7e86
msgid ""
"It is not possible to disable the check for division by zero or modulo by"
" zero using the ``unchecked`` block."
msgstr ""

#: ../../control-structures.rst:555 66430861bf16453e89c691899c243670
msgid ""
"Bitwise operators do not perform overflow or underflow checks. This is "
"particularly visible when using bitwise shifts (``<<``, ``>>``, ``<<=``, "
"``>>=``) in place of integer division and multiplication by a power of 2."
" For example ``type(uint256).max << 3`` does not revert even though "
"``type(uint256).max * 8`` would."
msgstr ""

#: ../../control-structures.rst:561 dfc9d4c7108347be88fe1bd4b02a73e2
msgid ""
"The second statement in ``int x = type(int).min; -x;`` will result in an "
"overflow because the negative range can hold one more value than the "
"positive range."
msgstr ""

#: ../../control-structures.rst:564 d503c99b08c04de686021452bdac106e
msgid ""
"Explicit type conversions will always truncate and never cause a failing "
"assertion with the exception of a conversion from an integer to an enum "
"type."
msgstr ""

#: ../../control-structures.rst:572 51132f829e384bf58ceec827f1b68d1a
msgid "Error handling: Assert, Require, Revert and Exceptions"
msgstr ""

#: ../../control-structures.rst:574 1b11d3e3a6784f4e828aa2b51dcc7e9d
msgid ""
"Solidity uses state-reverting exceptions to handle errors. Such an "
"exception undoes all changes made to the state in the current call (and "
"all its sub-calls) and flags an error to the caller."
msgstr ""

#: ../../control-structures.rst:579 af40d30319a943808bcb841ba713f14c
msgid ""
"When exceptions happen in a sub-call, they \"bubble up\" (i.e., "
"exceptions are rethrown) automatically unless they are caught in a "
"``try/catch`` statement. Exceptions to this rule are ``send`` and the "
"low-level functions ``call``, ``delegatecall`` and ``staticcall``: they "
"return ``false`` as their first return value in case of an exception "
"instead of \"bubbling up\"."
msgstr ""

#: ../../control-structures.rst:587 68903d80ed6c48f0813887b0c763c01d
msgid ""
"The low-level functions ``call``, ``delegatecall`` and ``staticcall`` "
"return ``true`` as their first return value if the account called is non-"
"existent, as part of the design of the EVM. Account existence must be "
"checked prior to calling if needed."
msgstr ""

#: ../../control-structures.rst:592 473af39aa6214e7c95082c37af66982c
msgid ""
"Exceptions can contain error data that is passed back to the caller in "
"the form of :ref:`error instances <errors>`. The built-in errors "
"``Error(string)`` and ``Panic(uint256)`` are used by special functions, "
"as explained below. ``Error`` is used for \"regular\" error conditions "
"while ``Panic`` is used for errors that should not be present in bug-free"
" code."
msgstr ""

#: ../../control-structures.rst:599 d5eb46a1f0a64913b29c767c512bd591
msgid "Panic via ``assert`` and Error via ``require``"
msgstr ""

#: ../../control-structures.rst:601 2420a9ff12044dc4bfbd990fe65b1218
msgid ""
"The convenience functions ``assert`` and ``require`` can be used to check"
" for conditions and throw an exception if the condition is not met."
msgstr ""

#: ../../control-structures.rst:604 b0496b794f094ea2b6059de4e1da9e01
msgid ""
"The ``assert`` function creates an error of type ``Panic(uint256)``. The "
"same error is created by the compiler in certain situations as listed "
"below."
msgstr ""

#: ../../control-structures.rst:607 4d6617a1d6c14595936e195cacfe1bf8
msgid ""
"Assert should only be used to test for internal errors, and to check "
"invariants. Properly functioning code should never create a Panic, not "
"even on invalid external input. If this happens, then there is a bug in "
"your contract which you should fix. Language analysis tools can evaluate "
"your contract to identify the conditions and function calls which will "
"cause a Panic."
msgstr ""

#: ../../control-structures.rst:615 79f41ad045cd48c8a34d8acba199dc45
msgid ""
"A Panic exception is generated in the following situations. The error "
"code supplied with the error data indicates the kind of panic."
msgstr ""

#: ../../control-structures.rst:618 be7e994a81734d61bc03d993f9c32fbb
msgid "0x00: Used for generic compiler inserted panics."
msgstr ""

#: ../../control-structures.rst:619 8585777bb4bb412aa678f2a5cab544e4
msgid "0x01: If you call ``assert`` with an argument that evaluates to false."
msgstr ""

#: ../../control-structures.rst:620 0ee6f5d72c4a4748a0764cc6d542ead6
msgid ""
"0x11: If an arithmetic operation results in underflow or overflow outside"
" of an ``unchecked { ... }`` block."
msgstr ""

#: ../../control-structures.rst:621 15c3ba2b316f47158beb64fc4986efce
msgid "0x12; If you divide or modulo by zero (e.g. ``5 / 0`` or ``23 % 0``)."
msgstr ""

#: ../../control-structures.rst:622 2ac1ec2066c04305b0ea3e38e9928634
msgid ""
"0x21: If you convert a value that is too big or negative into an enum "
"type."
msgstr ""

#: ../../control-structures.rst:623 79482f572a614283a55c55a4648e2e9a
msgid "0x22: If you access a storage byte array that is incorrectly encoded."
msgstr ""

#: ../../control-structures.rst:624 db03363fd9484fa6a893c0d09475d7ee
msgid "0x31: If you call ``.pop()`` on an empty array."
msgstr ""

#: ../../control-structures.rst:625 4c43fa0083c447d0b59872a9cffb1d7e
msgid ""
"0x32: If you access an array, ``bytesN`` or an array slice at an out-of-"
"bounds or negative index (i.e. ``x[i]`` where ``i >= x.length`` or ``i < "
"0``)."
msgstr ""

#: ../../control-structures.rst:626 2611c4b1adc2421cb712ca231a5b6c7d
msgid ""
"0x41: If you allocate too much memory or create an array that is too "
"large."
msgstr ""

#: ../../control-structures.rst:627 3c299684d761418b94822034d4381679
msgid "0x51: If you call a zero-initialized variable of internal function type."
msgstr ""

#: ../../control-structures.rst:629 aff492bdbab64e54a61558ab52e651db
msgid ""
"The ``require`` function either creates an error without any data or an "
"error of type ``Error(string)``. It should be used to ensure valid "
"conditions that cannot be detected until execution time. This includes "
"conditions on inputs or return values from calls to external contracts."
msgstr ""

#: ../../control-structures.rst:638 e75db64f876c46fe9c46f3a781472d8b
msgid ""
"It is currently not possible to use custom errors in combination with "
"``require``. Please use ``if (!condition) revert CustomError();`` "
"instead."
msgstr ""

#: ../../control-structures.rst:641 03d935c00e264adaabcc579ba6e12e84
msgid ""
"An ``Error(string)`` exception (or an exception without data) is "
"generated by the compiler in the following situations:"
msgstr ""

#: ../../control-structures.rst:645 bc5032ef3c594c00a8cb4b51b41ec627
msgid "Calling ``require(x)`` where ``x`` evaluates to ``false``."
msgstr ""

#: ../../control-structures.rst:646 bf0cfe5e6a054155a945a0ce51a677b0
msgid "If you use ``revert()`` or ``revert(\"description\")``."
msgstr ""

#: ../../control-structures.rst:647 c3a1505215294697b7c38974850dc6e9
msgid ""
"If you perform an external function call targeting a contract that "
"contains no code."
msgstr ""

#: ../../control-structures.rst:648 458e2d77a6a5494aba39653dee65a0bf
msgid ""
"If your contract receives Ether via a public function without ``payable``"
" modifier (including the constructor and the fallback function)."
msgstr ""

#: ../../control-structures.rst:650 2468eb35286e4a9dab31df50e0c015ae
msgid "If your contract receives Ether via a public getter function."
msgstr ""

#: ../../control-structures.rst:652 7d3803db7d4d4e7fb26bf7d7287c67ff
msgid ""
"For the following cases, the error data from the external call (if "
"provided) is forwarded. This means that it can either cause an `Error` or"
" a `Panic` (or whatever else was given):"
msgstr ""

#: ../../control-structures.rst:656 1727f900c02a45ec829b74dcc2a246a4
msgid "If a ``.transfer()`` fails."
msgstr ""

#: ../../control-structures.rst:657 0a36458f3dfe4287829849557544f5f2
msgid ""
"If you call a function via a message call but it does not finish properly"
" (i.e., it runs out of gas, has no matching function, or throws an "
"exception itself), except when a low level operation ``call``, ``send``, "
"``delegatecall``, ``callcode`` or ``staticcall`` is used. The low level "
"operations never throw exceptions but indicate failures by returning "
"``false``."
msgstr ""

#: ../../control-structures.rst:663 5d65646320304240b25c22683d8e4095
msgid ""
"If you create a contract using the ``new`` keyword but the contract "
"creation :ref:`does not finish properly<creating-contracts>`."
msgstr ""

#: ../../control-structures.rst:666 098434a4a9dd45d2b95aa5be998e9fa5
msgid ""
"You can optionally provide a message string for ``require``, but not for "
"``assert``."
msgstr ""

#: ../../control-structures.rst:669 cade01fb434c4586a3ccb8ac83e2a102
msgid ""
"If you do not provide a string argument to ``require``, it will revert "
"with empty error data, not even including the error selector."
msgstr ""

#: ../../control-structures.rst:673 5120967a26de455cbf10392ee7839dba
msgid ""
"The following example shows how you can use ``require`` to check "
"conditions on inputs and ``assert`` for internal error checking."
msgstr ""

#: ../../control-structures.rst:695 824649fe65fc493883d9140822d04678
msgid ""
"Internally, Solidity performs a revert operation (instruction ``0xfd``). "
"This causes the EVM to revert all changes made to the state. The reason "
"for reverting is that there is no safe way to continue execution, because"
" an expected effect did not occur. Because we want to keep the atomicity "
"of transactions, the safest action is to revert all changes and make the "
"whole transaction (or at least call) without effect."
msgstr ""

#: ../../control-structures.rst:703 bf18f438d12848d8b197ca04f8025780
msgid ""
"In both cases, the caller can react on such failures using "
"``try``/``catch``, but the changes in the callee will always be reverted."
msgstr ""

#: ../../control-structures.rst:708 8b5976ed68164e4db0ffdd2ef69d0ceb
msgid ""
"Panic exceptions used to use the ``invalid`` opcode before Solidity "
"0.8.0, which consumed all gas available to the call. Exceptions that use "
"``require`` used to consume all gas until before the Metropolis release."
msgstr ""

#: ../../control-structures.rst:715 cd8a65b4786f45afa2ebc30da1de31df
msgid "``revert``"
msgstr ""

#: ../../control-structures.rst:717 471d7f209c464392a111f50a7ff63b8c
msgid ""
"A direct revert can be triggered using the ``revert`` statement and the "
"``revert`` function."
msgstr ""

#: ../../control-structures.rst:719 aa0209c25f7a4122891bea26e3e5187d
msgid ""
"The ``revert`` statement takes a custom error as direct argument without "
"parentheses:"
msgstr ""

#: ../../control-structures.rst:721 7cf26069286a4725b6a4bb0a482bcb77
msgid "revert CustomError(arg1, arg2);"
msgstr ""

#: ../../control-structures.rst:723 e5ee562075c74285b67ca0feb69ca60b
msgid ""
"For backwards-compatibility reasons, there is also the ``revert()`` "
"function, which uses parentheses and accepts a string:"
msgstr ""

#: ../../control-structures.rst:726 92920f885252453099b9c6b7216bf616
msgid "revert(); revert(\"description\");"
msgstr ""

#: ../../control-structures.rst:729 46e80729abfc40a091112cf6bccfffc4
msgid ""
"The error data will be passed back to the caller and can be caught there."
" Using ``revert()`` causes a revert without any error data while "
"``revert(\"description\")`` will create an ``Error(string)`` error."
msgstr ""

#: ../../control-structures.rst:733 a653b5953d8946709355b020a7eca779
msgid ""
"Using a custom error instance will usually be much cheaper than a string "
"description, because you can use the name of the error to describe it, "
"which is encoded in only four bytes. A longer description can be supplied"
" via NatSpec which does not incur any costs."
msgstr ""

#: ../../control-structures.rst:738 0b8b0ea27f2141d689bd7d04b1cb3237
msgid ""
"The following example shows how to use an error string and a custom error"
" instance together with ``revert`` and the equivalent ``require``:"
msgstr ""

#: ../../control-structures.rst:767 5e7c3b24c90745c480c8bc03db8606c3
msgid ""
"The two ways ``if (!condition) revert(...);`` and ``require(condition, "
"...);`` are equivalent as long as the arguments to ``revert`` and "
"``require`` do not have side-effects, for example if they are just "
"strings."
msgstr ""

#: ../../control-structures.rst:772 ac10b7b7048d44f7aaa46fc351bb203c
msgid ""
"The ``require`` function is evaluated just as any other function. This "
"means that all arguments are evaluated before the function itself is "
"executed. In particular, in ``require(condition, f())`` the function "
"``f`` is executed even if ``condition`` is true."
msgstr ""

#: ../../control-structures.rst:777 549c1dd3599841bcacf18819e965198a
msgid ""
"The provided string is :ref:`abi-encoded <ABI>` as if it were a call to a"
" function ``Error(string)``. In the above example, ``revert(\"Not enough "
"Ether provided.\");`` returns the following hexadecimal as error return "
"data:"
msgstr ""

#: ../../control-structures.rst:787 f5d33876dc984474b0de82f9ca896dac
msgid ""
"The provided message can be retrieved by the caller using "
"``try``/``catch`` as shown below."
msgstr ""

#: ../../control-structures.rst:790 1b79b6c6d66d4862ae5bbcd270dcaffe
msgid ""
"There used to be a keyword called ``throw`` with the same semantics as "
"``revert()`` which was deprecated in version 0.4.13 and removed in "
"version 0.5.0."
msgstr ""

#: ../../control-structures.rst:797 64a176e0eefb42f0b42192add81b57a7
msgid "``try``/``catch``"
msgstr ""

#: ../../control-structures.rst:799 af9b48f363e84783aae086bce0c0548e
msgid ""
"A failure in an external call can be caught using a try/catch statement, "
"as follows:"
msgstr ""

#: ../../control-structures.rst:838 5eaecb3fc33c48d9b9f0d1755735c808
msgid ""
"The ``try`` keyword has to be followed by an expression representing an "
"external function call or a contract creation (``new ContractName()``). "
"Errors inside the expression are not caught (for example if it is a "
"complex expression that also involves internal function calls), only a "
"revert happening inside the external call itself. The ``returns`` part "
"(which is optional) that follows declares return variables matching the "
"types returned by the external call. In case there was no error, these "
"variables are assigned and the contract's execution continues inside the "
"first success block. If the end of the success block is reached, "
"execution continues after the ``catch`` blocks."
msgstr ""

#: ../../control-structures.rst:847 210d82a018b4425e804da08f3989faf1
msgid ""
"Solidity supports different kinds of catch blocks depending on the type "
"of error:"
msgstr ""

#: ../../control-structures.rst:850 589211e59e994c2da70c735d3e8cf7e1
msgid ""
"``catch Error(string memory reason) { ... }``: This catch clause is "
"executed if the error was caused by ``revert(\"reasonString\")`` or "
"``require(false, \"reasonString\")`` (or an internal error that causes "
"such an exception)."
msgstr ""

#: ../../control-structures.rst:854 f7b3ee6855d64b99a1201452195688c3
msgid ""
"``catch Panic(uint errorCode) { ... }``: If the error was caused by a "
"panic, i.e. by a failing ``assert``, division by zero, invalid array "
"access, arithmetic overflow and others, this catch clause will be run."
msgstr ""

#: ../../control-structures.rst:857 ba710263105b4f8989509b524a9a791e
msgid ""
"``catch (bytes memory lowLevelData) { ... }``: This clause is executed if"
" the error signature does not match any other clause, if there was an "
"error while decoding the error message, or if no error data was provided "
"with the exception. The declared variable provides access to the low-"
"level error data in that case."
msgstr ""

#: ../../control-structures.rst:863 029e8ad53f0848d688fec399150e63c1
msgid ""
"``catch { ... }``: If you are not interested in the error data, you can "
"just use ``catch { ... }`` (even as the only catch clause) instead of the"
" previous clause."
msgstr ""

#: ../../control-structures.rst:867 ba85819a08d84248a2aa15a1e6143820
msgid ""
"It is planned to support other types of error data in the future. The "
"strings ``Error`` and ``Panic`` are currently parsed as is and are not "
"treated as identifiers."
msgstr ""

#: ../../control-structures.rst:870 5c7e79018cfd435ea8b88ce3b864998f
msgid ""
"In order to catch all error cases, you have to have at least the clause "
"``catch { ...}`` or the clause ``catch (bytes memory lowLevelData) { ... "
"}``."
msgstr ""

#: ../../control-structures.rst:873 2a91b83c2f9b45f69449c989ca9788a5
msgid ""
"The variables declared in the ``returns`` and the ``catch`` clause are "
"only in scope in the block that follows."
msgstr ""

#: ../../control-structures.rst:878 81138ecc280e4d4db9a39529e99c1021
msgid ""
"If an error happens during the decoding of the return data inside a try"
"/catch-statement, this causes an exception in the currently executing "
"contract and because of that, it is not caught in the catch clause. If "
"there is an error during decoding of ``catch Error(string memory "
"reason)`` and there is a low-level catch clause, this error is caught "
"there."
msgstr ""

#: ../../control-structures.rst:886 9daf62009cc146c1ba7e68d0ee5e30c4
msgid ""
"If execution reaches a catch-block, then the state-changing effects of "
"the external call have been reverted. If execution reaches the success "
"block, the effects were not reverted. If the effects have been reverted, "
"then execution either continues in a catch block or the execution of the "
"try/catch statement itself reverts (for example due to decoding failures "
"as noted above or due to not providing a low-level catch clause)."
msgstr ""

#: ../../control-structures.rst:895 aab9591f5f08436fad33b7afb97dc141
msgid ""
"The reason behind a failed call can be manifold. Do not assume that the "
"error message is coming directly from the called contract: The error "
"might have happened deeper down in the call chain and the called contract"
" just forwarded it. Also, it could be due to an out-of-gas situation and "
"not a deliberate error condition: The caller always retains at least "
"1/64th of the gas in a call and thus even if the called contract goes out"
" of gas, the caller still has some gas left."
msgstr ""

