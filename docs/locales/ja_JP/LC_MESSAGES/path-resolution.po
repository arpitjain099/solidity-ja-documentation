# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2016-2023, The Solidity Authors
# This file is distributed under the same license as the Solidity package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Solidity 0.8.20\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-03-18 04:40+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja_JP\n"
"Language-Team: ja_JP <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../path-resolution.rst:5 cd1e96b06582442695725f9f02794508
msgid "Import Path Resolution"
msgstr ""

#: ../../path-resolution.rst:7 f4fb31cb91dc4f18a9e967b2812aea5b
msgid ""
"In order to be able to support reproducible builds on all platforms, the "
"Solidity compiler has to abstract away the details of the filesystem "
"where source files are stored. Paths used in imports must work the same "
"way everywhere while the command-line interface must be able to work with"
" platform-specific paths to provide good user experience. This section "
"aims to explain in detail how Solidity reconciles these requirements."
msgstr ""

#: ../../path-resolution.rst:17 dfb7cd1bfc244d55af19e4bf1cd76075
msgid "Virtual Filesystem"
msgstr ""

#: ../../path-resolution.rst:19 dabda08fc5d24f41bbfc5fecee38aa0c
msgid ""
"The compiler maintains an internal database (*virtual filesystem* or "
"*VFS* for short) where each source unit is assigned a unique *source unit"
" name* which is an opaque and unstructured identifier. When you use the "
":ref:`import statement <import>`, you specify an *import path* that "
"references a source unit name."
msgstr ""

#: ../../path-resolution.rst:28 0480047f2a8543dc823d34d4e97f609c
msgid "Import Callback"
msgstr ""

#: ../../path-resolution.rst:30 1078a8ba9e2a427ea6667efd4bef7202
msgid ""
"The VFS is initially populated only with files the compiler has received "
"as input. Additional files can be loaded during compilation using an "
"*import callback*, which is different depending on the type of compiler "
"you use (see below). If the compiler does not find any source unit name "
"matching the import path in the VFS, it invokes the callback, which is "
"responsible for obtaining the source code to be placed under that name. "
"An import callback is free to interpret source unit names in an arbitrary"
" way, not just as paths. If there is no callback available when one is "
"needed or if it fails to locate the source code, compilation fails."
msgstr ""

#: ../../path-resolution.rst:39 708c6071f8814787aa5cc5f2b5d67890
msgid ""
"The command-line compiler provides the *Host Filesystem Loader* - a "
"rudimentary callback that interprets a source unit name as a path in the "
"local filesystem. The `JavaScript interface <https://github.com/ethereum"
"/solc-js>`_ does not provide any by default, but one can be provided by "
"the user. This mechanism can be used to obtain source code from locations"
" other then the local filesystem (which may not even be accessible, e.g. "
"when the compiler is running in a browser). For example the `Remix IDE "
"<https://remix.ethereum.org/>`_ provides a versatile callback that lets "
"you `import files from HTTP, IPFS and Swarm URLs or refer directly to "
"packages in NPM registry <https://remix-"
"ide.readthedocs.io/en/latest/import.html>`_."
msgstr ""

#: ../../path-resolution.rst:51 e96b0b0d7a2f4d15bc722d4fb3391a18
msgid ""
"Host Filesystem Loader's file lookup is platform-dependent. For example "
"backslashes in a source unit name can be interpreted as directory "
"separators or not and the lookup can be case-sensitive or not, depending "
"on the underlying platform."
msgstr ""

#: ../../path-resolution.rst:55 2b38a68b7dbe4ac683bbf21d8f304833
msgid ""
"For portability it is recommended to avoid using import paths that will "
"work correctly only with a specific import callback or only on one "
"platform. For example you should always use forward slashes since they "
"work as path separators also on platforms that support backslashes."
msgstr ""

#: ../../path-resolution.rst:61 a7db7fa7996b46bfaf2ee8e7b7a168ea
msgid "Initial Content of the Virtual Filesystem"
msgstr ""

#: ../../path-resolution.rst:63 8d0ecdbee4574f119ac8bc7e671733e9
msgid "The initial content of the VFS depends on how you invoke the compiler:"
msgstr ""

#: ../../path-resolution.rst:65 4d6c628b75bf469fb63db9ae888ba859
msgid "**solc / command-line interface**"
msgstr ""

#: ../../path-resolution.rst:67 0660ca6bb3344e609fc1ee9f275ccf83
msgid ""
"When you compile a file using the command-line interface of the compiler,"
" you provide one or more paths to files containing Solidity code:"
msgstr ""

#: ../../path-resolution.rst:74 4b8f73c8bbbc489aaba1bf8d782da49f
msgid ""
"The source unit name of a file loaded this way is constructed by "
"converting its path to a canonical form and, if possible, making it "
"relative to either the base path or one of the include paths. See "
":ref:`CLI Path Normalization and Stripping <cli-path-normalization-and-"
"stripping>` for a detailed description of this process."
msgstr ""

#: ../../path-resolution.rst:82 3ea170b138184e818d538dd704cfaf86
msgid "**Standard JSON**"
msgstr ""

#: ../../path-resolution.rst:84 ead7b1c630ee430c9b6dc270ba44d81e
msgid ""
"When using the :ref:`Standard JSON <compiler-api>` API (via either the "
"`JavaScript interface <https://github.com/ethereum/solc-js>`_ or the "
"``--standard-json`` command-line option) you provide input in JSON "
"format, containing, among other things, the content of all your source "
"files:"
msgstr ""

#: ../../path-resolution.rst:107 651bf998a4a34f1aaa91c0d495b15e46
msgid ""
"The ``sources`` dictionary becomes the initial content of the virtual "
"filesystem and its keys are used as source unit names."
msgstr ""

#: ../../path-resolution.rst:112 07d1639257724d1d8bf9c71878be7983
msgid "**Standard JSON (via import callback)**"
msgstr ""

#: ../../path-resolution.rst:114 76c64fc1edd0441d8bcdd1a3b17b4e18
msgid ""
"With Standard JSON it is also possible to tell the compiler to use the "
"import callback to obtain the source code:"
msgstr ""

#: ../../path-resolution.rst:132 0445940768aa4f8fbafde1781952966d
msgid ""
"If an import callback is available, the compiler will give it the strings"
" specified in ``urls`` one by one, until one is loaded successfully or "
"the end of the list is reached."
msgstr ""

#: ../../path-resolution.rst:135 7a0f939ad59148a0a3745f8732bcf35f
msgid ""
"The source unit names are determined the same way as when using "
"``content`` - they are keys of the ``sources`` dictionary and the content"
" of ``urls`` does not affect them in any way."
msgstr ""

#: ../../path-resolution.rst:140 16fa3fd0a08049e3bc7c18c0e3960f41
msgid "**Standard input**"
msgstr ""

#: ../../path-resolution.rst:142 ffd07956c8d048388387b4684f2ebced
msgid ""
"On the command line it is also possible to provide the source by sending "
"it to compiler's standard input:"
msgstr ""

#: ../../path-resolution.rst:149 0ca77c13246d48a88f3a62f3b4fe4a29
msgid ""
"``-`` used as one of the arguments instructs the compiler to place the "
"content of the standard input in the virtual filesystem under a special "
"source unit name: ``<stdin>``."
msgstr ""

#: ../../path-resolution.rst:152 3a5291f6afb943eaa0aac0af88a3adb3
msgid ""
"Once the VFS is initialized, additional files can still be added to it "
"only through the import callback."
msgstr ""

#: ../../path-resolution.rst:158 abe9e33e434741d588bce368b78ab54c
msgid "Imports"
msgstr ""

#: ../../path-resolution.rst:160 eda4d2ddbe0d44369df741a0a085347f
msgid ""
"The import statement specifies an *import path*. Based on how the import "
"path is specified, we can divide imports into two categories:"
msgstr ""

#: ../../path-resolution.rst:163 801c9a55612847d6843539625135eb30
msgid ""
":ref:`Direct imports <direct-imports>`, where you specify the full source"
" unit name directly."
msgstr ""

#: ../../path-resolution.rst:164 a50711074b6241c9a5aa32c942ca768f
msgid ""
":ref:`Relative imports <relative-imports>`, where you specify a path "
"starting with ``./`` or ``../`` to be combined with the source unit name "
"of the importing file."
msgstr ""

#: ../../path-resolution.rst:168 3152b68eafac4ccf9ed0e5f4cff747a8
msgid "contracts/contract.sol"
msgstr ""

#: ../../path-resolution.rst:174 0a4878d907a349578fb15ae1a112ddd3
msgid ""
"In the above ``./math/math.sol`` and ``contracts/tokens/token.sol`` are "
"import paths while the source unit names they translate to are "
"``contracts/math/math.sol`` and ``contracts/tokens/token.sol`` "
"respectively."
msgstr ""

#: ../../path-resolution.rst:182 63a2489c3984487192d03be91f660098
msgid "Direct Imports"
msgstr ""

#: ../../path-resolution.rst:184 45bc89041d6942138b9e224234683f78
msgid "An import that does not start with ``./`` or ``../`` is a *direct import*."
msgstr ""

#: ../../path-resolution.rst:193 e7fa1edd306b43be9df0fdabbb6fd595
msgid ""
"After applying any :ref:`import remappings <import-remapping>` the import"
" path simply becomes the source unit name."
msgstr ""

#: ../../path-resolution.rst:198 c216b9cb502348808d3ec6ca850ae05c
msgid ""
"A source unit name is just an identifier and even if its value happens to"
" look like a path, it is not subject to the normalization rules you would"
" typically expect in a shell. Any ``/./`` or ``/../`` segments or "
"sequences of multiple slashes remain a part of it. When the source is "
"provided via Standard JSON interface it is entirely possible to associate"
" different content with source unit names that would refer to the same "
"file on disk."
msgstr ""

#: ../../path-resolution.rst:204 0b88aeae773b40e78f38aa730ac672a7
msgid ""
"When the source is not available in the virtual filesystem, the compiler "
"passes the source unit name to the import callback. The Host Filesystem "
"Loader will attempt to use it as a path and look up the file on disk. At "
"this point the platform-specific normalization rules kick in and names "
"that were considered different in the VFS may actually result in the same"
" file being loaded. For example ``/project/lib/math.sol`` and "
"``/project/lib/../lib///math.sol`` are considered completely different in"
" the VFS even though they refer to the same file on disk."
msgstr ""

#: ../../path-resolution.rst:214 0ea7a97b47884135bcb888b9e1ae3f0e
msgid ""
"Even if an import callback ends up loading source code for two different "
"source unit names from the same file on disk, the compiler will still see"
" them as separate source units. It is the source unit name that matters, "
"not the physical location of the code."
msgstr ""

#: ../../path-resolution.rst:222 246ad2f41cfb47b6ab9f2d2a7b08794b
msgid "Relative Imports"
msgstr ""

#: ../../path-resolution.rst:224 f16eb472277d455a9168360d0df8adaa
msgid ""
"An import starting with ``./`` or ``../`` is a *relative import*. Such "
"imports specify a path relative to the source unit name of the importing "
"source unit:"
msgstr ""

#: ../../path-resolution.rst:227 c27b3d14166d4af5aa32d5373a7ddf86
msgid "/project/lib/math.sol"
msgstr ""

#: ../../path-resolution.rst:233 55566e159dcd484f81d88756b1a777d6
msgid "lib/math.sol"
msgstr ""

#: ../../path-resolution.rst:241 2f9597409e624c9eac51db074bca2b61
msgid ""
"Relative imports **always** start with ``./`` or ``../`` so ``import "
"\"util.sol\"``, unlike ``import \"./util.sol\"``, is a direct import. "
"While both paths would be considered relative in the host filesystem, "
"``util.sol`` is actually absolute in the VFS."
msgstr ""

#: ../../path-resolution.rst:246 8d106bc8c6d145d28690cf8a48390d10
msgid ""
"Let us define a *path segment* as any non-empty part of the path that "
"does not contain a separator and is bounded by two path separators. A "
"separator is a forward slash or the beginning/end of the string. For "
"example in ``./abc/..//`` there are three path segments: ``.``, ``abc`` "
"and ``..``."
msgstr ""

#: ../../path-resolution.rst:251 cf12f354ba434641ac62b2e91c67923c
msgid ""
"The compiler resolves the import into a source unit name based on the "
"import path, in the following way:"
msgstr ""

#: ../../path-resolution.rst:253 1a14f3761d6c4e4fa0acf2f93e7b840e
msgid "We start with the source unit name of the importing source unit."
msgstr ""

#: ../../path-resolution.rst:254 5ab8926ee408424287a3787681eb3bad
msgid ""
"The last path segment with preceding slashes is removed from the resolved"
" name."
msgstr ""

#: ../../path-resolution.rst:258 3f3a2d05f3b34527af334dcd7ada1546
msgid ""
"Then, for every segment in the import path, starting from the leftmost "
"one:"
msgstr ""

#: ../../path-resolution.rst:256 688f1d9b4b6d45b1b5244871e9b32a10
msgid "If the segment is ``.``, it is skipped."
msgstr ""

#: ../../path-resolution.rst:257 f872757c962d4d96910a046a702caaad
msgid ""
"If the segment is ``..``, the last path segment with preceding slashes is"
" removed from the resolved name."
msgstr ""

#: ../../path-resolution.rst:258 c0810e25e2d74e51896e377c58a82e7c
msgid ""
"Otherwise, the segment (preceded by a single slash if the resolved name "
"is not empty), is appended to the resolved name."
msgstr ""

#: ../../path-resolution.rst:260 f326e4da29dc4717b9adb5741ae94cad
msgid ""
"The removal of the last path segment with preceding slashes is understood"
" to work as follows:"
msgstr ""

#: ../../path-resolution.rst:263 06f1c2269b304071ada2e90e782fb5d8
msgid ""
"Everything past the last slash is removed (i.e. ``a/b//c.sol`` becomes "
"``a/b//``)."
msgstr ""

#: ../../path-resolution.rst:264 6f183b76aa0744d6b88ccc95d7e6dbc4
msgid "All trailing slashes are removed (i.e. ``a/b//`` becomes ``a/b``)."
msgstr ""

#: ../../path-resolution.rst:266 1e0e8ae37cdb4c1cbffba461a9ac5b60
msgid ""
"Note that the process normalizes the part of the resolved source unit "
"name that comes from the import path according to the usual rules for "
"UNIX paths, i.e. all ``.`` and ``..`` are removed and multiple slashes "
"are squashed into a single one. On the other hand, the part that comes "
"from the source unit name of the importing module remains unnormalized. "
"This ensures that the ``protocol://`` part does not turn into "
"``protocol:/`` if the importing file is identified with a URL."
msgstr ""

#: ../../path-resolution.rst:273 8bcd6b95dd6946829dee378308698d5e
msgid ""
"If your import paths are already normalized, you can expect the above "
"algorithm to produce very intuitive results. Here are some examples of "
"what you can expect if they are not:"
msgstr ""

#: ../../path-resolution.rst:277 bb74ea1db0b34ff891998a42618f7862
msgid "lib/src/../contract.sol"
msgstr ""

#: ../../path-resolution.rst:288 b0b57cafa4584f27808bcf9d082a1286
msgid ""
"The use of relative imports containing leading ``..`` segments is not "
"recommended. The same effect can be achieved in a more reliable way by "
"using direct imports with :ref:`base path and include paths <base-and-"
"include-paths>`."
msgstr ""

#: ../../path-resolution.rst:296 1c36f2d623264b8b96214b9974626e3b
msgid "Base Path and Include Paths"
msgstr ""

#: ../../path-resolution.rst:298 1091596fe2bc4c1093df50f692b59ed9
msgid ""
"The base path and include paths represent directories that the Host "
"Filesystem Loader will load files from. When a source unit name is passed"
" to the loader, it prepends the base path to it and performs a filesystem"
" lookup. If the lookup does not succeed, the same is done with all "
"directories on the include path list."
msgstr ""

#: ../../path-resolution.rst:303 cb51f9fdad3b456e842c119bc9790ea6
msgid ""
"It is recommended to set the base path to the root directory of your "
"project and use include paths to specify additional locations that may "
"contain libraries your project depends on. This lets you import from "
"these libraries in a uniform way, no matter where they are located in the"
" filesystem relative to your project. For example, if you use npm to "
"install packages and your contract imports "
"``@openzeppelin/contracts/utils/Strings.sol``, you can use these options "
"to tell the compiler that the library can be found in one of the npm "
"package directories:"
msgstr ""

#: ../../path-resolution.rst:318 bc58f873f8584dd09e530c5fac9b0dbe
msgid ""
"Your contract will compile (with the same exact metadata) no matter "
"whether you install the library in the local or global package directory "
"or even directly under your project root."
msgstr ""

#: ../../path-resolution.rst:321 35f9da2e1ca64373851a1ae7a4f6c531
msgid ""
"By default the base path is empty, which leaves the source unit name "
"unchanged. When the source unit name is a relative path, this results in "
"the file being looked up in the directory the compiler has been invoked "
"from. It is also the only value that results in absolute paths in source "
"unit names being actually interpreted as absolute paths on disk. If the "
"base path itself is relative, it is interpreted as relative to the "
"current working directory of the compiler."
msgstr ""

#: ../../path-resolution.rst:331 40b6c1869bde4efc9aa7e6deea9d55fc
msgid ""
"Include paths cannot have empty values and must be used together with a "
"non-empty base path."
msgstr ""

#: ../../path-resolution.rst:335 c643a2b87afb4b95aa84bae91c8528eb
msgid ""
"Include paths and base path can overlap as long as it does not make "
"import resolution ambiguous. For example, you can specify a directory "
"inside base path as an include directory or have an include directory "
"that is a subdirectory of another include directory. The compiler will "
"only issue an error if the source unit name passed to the Host Filesystem"
" Loader represents an existing path when combined with multiple include "
"paths or an include path and base path."
msgstr ""

#: ../../path-resolution.rst:345 06c72031007b4ba0b62ad1ee53f222da
msgid "CLI Path Normalization and Stripping"
msgstr ""

#: ../../path-resolution.rst:347 4d375eb0be814511a6e284533094d35c
msgid ""
"On the command line the compiler behaves just as you would expect from "
"any other program: it accepts paths in a format native to the platform "
"and relative paths are relative to the current working directory. The "
"source unit names assigned to files whose paths are specified on the "
"command line, however, should not change just because the project is "
"being compiled on a different platform or because the compiler happens to"
" have been invoked from a different directory. To achieve this, paths to "
"source files coming from the command line must be converted to a "
"canonical form, and, if possible, made relative to the base path or one "
"of the include paths."
msgstr ""

#: ../../path-resolution.rst:356 cec8aaabefbf4fdf914b64125ef0f4c6
msgid "The normalization rules are as follows:"
msgstr ""

#: ../../path-resolution.rst:358 8e17b181b74b4aa7ab280d676c538bf8
msgid ""
"If a path is relative, it is made absolute by prepending the current "
"working directory to it."
msgstr ""

#: ../../path-resolution.rst:359 edb2d0865f784e458f90211664236051
msgid "Internal ``.`` and ``..`` segments are collapsed."
msgstr ""

#: ../../path-resolution.rst:360 08a7be2c4c0d4fb7ab456e1edb0e9377
msgid "Platform-specific path separators are replaced with forward slashes."
msgstr ""

#: ../../path-resolution.rst:361 b8c28edb0f26435c84cc79680eeac3b1
msgid ""
"Sequences of multiple consecutive path separators are squashed into a "
"single separator (unless they are the leading slashes of an `UNC path "
"<https://en.wikipedia.org/wiki/Path_(computing)#UNC>`_)."
msgstr ""

#: ../../path-resolution.rst:363 2734e35537714a19844e1d1884b23c87
msgid ""
"If the path includes a root name (e.g. a drive letter on Windows) and the"
" root is the same as the root of the current working directory, the root "
"is replaced with ``/``."
msgstr ""

#: ../../path-resolution.rst:365 3ee0646fb04c4948ae551886b50d8f40
msgid "Symbolic links in the path are **not** resolved."
msgstr ""

#: ../../path-resolution.rst:367 31513d54d0b548b599e9fdc9b51bdc3d
msgid ""
"The only exception is the path to the current working directory prepended"
" to relative paths in the process of making them absolute. On some "
"platforms the working directory is reported always with symbolic links "
"resolved so for consistency the compiler resolves them everywhere."
msgstr ""

#: ../../path-resolution.rst:372 7a0fd09203004096bcb7f06d78a7fb62
msgid ""
"The original case of the path is preserved even if the filesystem is "
"case-insensitive but `case-preserving "
"<https://en.wikipedia.org/wiki/Case_preservation>`_ and the actual case "
"on disk is different."
msgstr ""

#: ../../path-resolution.rst:378 21ac2ce14bb1474ea07c4d4b0f68630d
msgid ""
"There are situations where paths cannot be made platform-independent. For"
" example on Windows the compiler can avoid using drive letters by "
"referring to the root directory of the current drive as ``/`` but drive "
"letters are still necessary for paths leading to other drives. You can "
"avoid such situations by ensuring that all the files are available within"
" a single directory tree on the same drive."
msgstr ""

#: ../../path-resolution.rst:385 05784fa8b6a94e32a80a2dbe0e4649f6
msgid ""
"After normalization the compiler attempts to make the source file path "
"relative. It tries the base path first and then the include paths in the "
"order they were given. If the base path is empty or not specified, it is "
"treated as if it was equal to the path to the current working directory "
"(with all symbolic links resolved). The result is accepted only if the "
"normalized directory path is the exact prefix of the normalized file "
"path. Otherwise the file path remains absolute. This makes the conversion"
" unambiguous and ensures that the relative path does not start with "
"``../``. The resulting file path becomes the source unit name."
msgstr ""

#: ../../path-resolution.rst:397 5d41da81509e4dedbebc352ae0671559
msgid ""
"The relative path produced by stripping must remain unique within the "
"base path and include paths. For example the compiler will issue an error"
" for the following command if both ``/project/contract.sol`` and "
"``/lib/contract.sol`` exist:"
msgstr ""

#: ../../path-resolution.rst:407 2e98bc990f7048f1894f3fbc9863766a
msgid ""
"Prior to version 0.8.8, CLI path stripping was not performed and the only"
" normalization applied was the conversion of path separators. When "
"working with older versions of the compiler it is recommended to invoke "
"the compiler from the base path and to only use relative paths on the "
"command line."
msgstr ""

#: ../../path-resolution.rst:416 2546d54b9f4141dfaf2d6e97b3aa06b4
msgid "Allowed Paths"
msgstr ""

#: ../../path-resolution.rst:418 551b74f60fe6481aba5b192e0c3c8be3
msgid ""
"As a security measure, the Host Filesystem Loader will refuse to load "
"files from outside of a few locations that are considered safe by "
"default:"
msgstr ""

#: ../../path-resolution.rst:421 982be461e1994d5986392b8f78f1e1d5
msgid "Outside of Standard JSON mode:"
msgstr ""

#: ../../path-resolution.rst:423 b3b6ac1231df49919a7de88b9de63031
msgid "The directories containing input files listed on the command line."
msgstr ""

#: ../../path-resolution.rst:424 84dd010a596340b29bfe608bd8294fe9
msgid ""
"The directories used as :ref:`remapping <import-remapping>` targets. If "
"the target is not a directory (i.e does not end with ``/``, ``/.`` or "
"``/..``) the directory containing the target is used instead."
msgstr ""

#: ../../path-resolution.rst:427 ../../path-resolution.rst:431
#: 7841893fba794f8e8a4c6ce51e2072a0 c0596a3f8635450ab207bd2f740ca5f4
msgid "Base path and include paths."
msgstr ""

#: ../../path-resolution.rst:429 b6e3271ffe4d42cebca6e978f098a9c6
msgid "In Standard JSON mode:"
msgstr ""

#: ../../path-resolution.rst:433 af84cc9be192485abb15978d9e6dad0b
msgid ""
"Additional directories can be whitelisted using the ``--allow-paths`` "
"option. The option accepts a comma-separated list of paths:"
msgstr ""

#: ../../path-resolution.rst:445 6cb5f68e18354d8aac9e71a6a176821c
msgid ""
"When the compiler is invoked with the command shown above, the Host "
"Filesystem Loader will allow importing files from the following "
"directories:"
msgstr ""

#: ../../path-resolution.rst:448 0669a60105574809943a36507bbd4977
msgid ""
"``/home/user/project/token/`` (because ``token/`` contains the input file"
" and also because it is the base path),"
msgstr ""

#: ../../path-resolution.rst:450 1e60f43c96c84cd8a46e1683d4b5c607
msgid "``/lib/`` (because ``/lib/`` is one of the include paths),"
msgstr ""

#: ../../path-resolution.rst:451 d14cf4c20a2b4a1bb74b675d9be26479
msgid ""
"``/home/user/project/libs/`` (because ``libs/`` is a directory containing"
" a remapping target),"
msgstr ""

#: ../../path-resolution.rst:452 5e6804bc6e524a798f68ee7810215fba
msgid ""
"``/home/user/utils/`` (because of ``../utils/`` passed to ``--allow-"
"paths``),"
msgstr ""

#: ../../path-resolution.rst:453 bfd155b8536f4353aec4579945b8d640
msgid ""
"``/tmp/libraries/`` (because of ``/tmp/libraries`` passed to ``--allow-"
"paths``),"
msgstr ""

#: ../../path-resolution.rst:457 5bf3e072feb34b80b25620af2e70b757
msgid ""
"The working directory of the compiler is one of the paths allowed by "
"default only if it happens to be the base path (or the base path is not "
"specified or has an empty value)."
msgstr ""

#: ../../path-resolution.rst:462 c5e34736f13540b280600d73f52e99a7
msgid ""
"The compiler does not check if allowed paths actually exist and whether "
"they are directories. Non-existent or empty paths are simply ignored. If "
"an allowed path matches a file rather than a directory, the file is "
"considered whitelisted, too."
msgstr ""

#: ../../path-resolution.rst:468 8be84a9e04dc4cb49ec933d1f27eb322
msgid ""
"Allowed paths are case-sensitive even if the filesystem is not. The case "
"must exactly match the one used in your imports. For example ``--allow-"
"paths tokens`` will not match ``import \"Tokens/IERC20.sol\"``."
msgstr ""

#: ../../path-resolution.rst:474 8d8d4e3fe8954fcdb43aef30260560c3
msgid ""
"Files and directories only reachable through symbolic links from allowed "
"directories are not automatically whitelisted. For example if "
"``token/contract.sol`` in the example above was actually a symlink "
"pointing at ``/etc/passwd`` the compiler would refuse to load it unless "
"``/etc/`` was one of the allowed paths too."
msgstr ""

#: ../../path-resolution.rst:484 aa604bf1edec42c1a3e9a7194e02b5d3
msgid "Import Remapping"
msgstr ""

#: ../../path-resolution.rst:486 a7daa095c52548a297c6780f53cf6b80
msgid ""
"Import remapping allows you to redirect imports to a different location "
"in the virtual filesystem. The mechanism works by changing the "
"translation between import paths and source unit names. For example you "
"can set up a remapping so that any import from the virtual directory "
"``github.com/ethereum/dapp-bin/library/`` would be seen as an import from"
" ``dapp-bin/library/`` instead."
msgstr ""

#: ../../path-resolution.rst:491 a3406f7615244163a70bde381e5350d2
msgid ""
"You can limit the scope of a remapping by specifying a *context*. This "
"allows creating remappings that apply only to imports located in a "
"specific library or a specific file. Without a context a remapping is "
"applied to every matching import in all the files in the virtual "
"filesystem."
msgstr ""

#: ../../path-resolution.rst:496 70b03757fc3f46809a9201be083eeeae
msgid "Import remappings have the form of ``context:prefix=target``:"
msgstr ""

#: ../../path-resolution.rst:498 453a8376bc704f04aa0462688514cb8e
msgid ""
"``context`` must match the beginning of the source unit name of the file "
"containing the import."
msgstr ""

#: ../../path-resolution.rst:499 aef3b4712de5443fad850541d94d0775
msgid ""
"``prefix`` must match the beginning of the source unit name resulting "
"from the import."
msgstr ""

#: ../../path-resolution.rst:500 643b60c8219a4d57a5253bfc54ae4454
msgid "``target`` is the value the prefix is replaced with."
msgstr ""

#: ../../path-resolution.rst:502 be05aa5a6327473da721765c796510df
msgid ""
"For example, if you clone https://github.com/ethereum/dapp-bin/ locally "
"to ``/project/dapp-bin`` and run the compiler with:"
msgstr ""

#: ../../path-resolution.rst:509 59fe3662584943759315e064ea230429
msgid "you can use the following in your source file:"
msgstr ""

#: ../../path-resolution.rst:515 8bf32da2d5064b5a90bdafccfb82c146
msgid ""
"The compiler will look for the file in the VFS under ``dapp-"
"bin/library/math.sol``. If the file is not available there, the source "
"unit name will be passed to the Host Filesystem Loader, which will then "
"look in ``/project/dapp-bin/library/iterable_mapping.sol``."
msgstr ""

#: ../../path-resolution.rst:521 34ae8cdb1c384d9b8239690ab0d70915
msgid ""
"Information about remappings is stored in contract metadata. Since the "
"binary produced by the compiler has a hash of the metadata embedded in "
"it, any modification to the remappings will result in different bytecode."
msgstr ""

#: ../../path-resolution.rst:525 4abe1ab622e8440f81ea6b4fbf6d5cf5
msgid ""
"For this reason you should be careful not to include any local "
"information in remapping targets. For example if your library is located "
"in ``/home/user/packages/mymath/math.sol``, a remapping like "
"``@math/=/home/user/packages/mymath/`` would result in your home "
"directory being included in the metadata. To be able to reproduce the "
"same bytecode with such a remapping on a different machine, you would "
"need to recreate parts of your local directory structure in the VFS and "
"(if you rely on Host Filesystem Loader) also in the host filesystem."
msgstr ""

#: ../../path-resolution.rst:533 cee82c9e894e48ce8d58c9ec48debb17
msgid ""
"To avoid having your local directory structure embedded in the metadata, "
"it is recommended to designate the directories containing libraries as "
"*include paths* instead. For example, in the example above ``--include-"
"path /home/user/packages/`` would let you use imports starting with "
"``mymath/``. Unlike remapping, the option on its own will not make "
"``mymath`` appear as ``@math`` but this can be achieved by creating a "
"symbolic link or renaming the package subdirectory."
msgstr ""

#: ../../path-resolution.rst:540 acbaeedd943d45bcb0126d3b03175ac4
msgid ""
"As a more complex example, suppose you rely on a module that uses an old "
"version of dapp-bin that you checked out to ``/project/dapp-bin_old``, "
"then you can run:"
msgstr ""

#: ../../path-resolution.rst:550 5aaf48eab85f444b8f0984ee2c99810b
msgid ""
"This means that all imports in ``module2`` point to the old version but "
"imports in ``module1`` point to the new version."
msgstr ""

#: ../../path-resolution.rst:553 0cb45d522213497cbd2c08c782889481
msgid "Here are the detailed rules governing the behaviour of remappings:"
msgstr ""

#: ../../path-resolution.rst:555 b45115c22052454ca6fd9574e40b678f
msgid ""
"**Remappings only affect the translation between import paths and source "
"unit names.**"
msgstr ""

#: ../../path-resolution.rst:557 56da0708e23d473196e05b1043648028
msgid ""
"Source unit names added to the VFS in any other way cannot be remapped. "
"For example the paths you specify on the command-line and the ones in "
"``sources.urls`` in Standard JSON are not affected."
msgstr ""

#: ../../path-resolution.rst:565 17dc85bb5f384009b269c91e3bce4b92
msgid ""
"In the example above the compiler will load the source code from "
"``/project/contract.sol`` and place it under that exact source unit name "
"in the VFS, not under ``/contract/contract.sol``."
msgstr ""

#: ../../path-resolution.rst:568 b31b2a72dc064d729da2be9fa9186a04
msgid "**Context and prefix must match source unit names, not import paths.**"
msgstr ""

#: ../../path-resolution.rst:570 a9df9ea786704e79967c639caa878b6d
msgid ""
"This means that you cannot remap ``./`` or ``../`` directly since they "
"are replaced during the translation to source unit name but you can remap"
" the part of the name they are replaced with:"
msgstr ""

#: ../../path-resolution.rst:578 ../../path-resolution.rst:590
#: ../../path-resolution.rst:615 3e5b7effe9c9467ab9e45ed23da48a50
#: ae2bd8b335c24a0c9d9366fe35703b53 d8c84a0728604b699662dae442e44ec5
msgid "/project/contract.sol"
msgstr ""

#: ../../path-resolution.rst:583 020442a74bf64b988e6ef2a4a8d6338f
msgid ""
"You cannot remap base path or any other part of the path that is only "
"added internally by an import callback:"
msgstr ""

#: ../../path-resolution.rst:595 95d77afdc5134a96aa8c06ee00b2a8af
msgid ""
"**Target is inserted directly into the source unit name and does not "
"necessarily have to be a valid path.**"
msgstr ""

#: ../../path-resolution.rst:597 9e274020518f4c728673019dbef772e5
msgid ""
"It can be anything as long as the import callback can handle it. In case "
"of the Host Filesystem Loader this includes also relative paths. When "
"using the JavaScript interface you can even use URLs and abstract "
"identifiers if your callback can handle them."
msgstr ""

#: ../../path-resolution.rst:602 9aebf014ec574ea1a25b0aa182285ec7
msgid ""
"Remapping happens after relative imports have already been resolved into "
"source unit names. This means that targets starting with ``./`` and "
"``../`` have no special meaning and are relative to the base path rather "
"than to the location of the source file."
msgstr ""

#: ../../path-resolution.rst:606 9b97ad70081b431fb67486760d05bcc0
msgid ""
"Remapping targets are not normalized so ``@root/=./a/b//`` will remap "
"``@root/contract.sol`` to ``./a/b//contract.sol`` and not "
"``a/b/contract.sol``."
msgstr ""

#: ../../path-resolution.rst:609 0a5b7a8df73844be83996ebec41ee54e
msgid ""
"If the target does not end with a slash, the compiler will not add one "
"automatically:"
msgstr ""

#: ../../path-resolution.rst:620 8ce9323bbfdf4001b35c567969518618
msgid "**Context and prefix are patterns and matches must be exact.**"
msgstr ""

#: ../../path-resolution.rst:622 6b1f389fa0a546509e3ec2fc0bb1b26d
msgid "``a//b=c`` will not match ``a/b``."
msgstr ""

#: ../../path-resolution.rst:623 3fb4259193674922bb555cfbd0636d12
msgid ""
"source unit names are not normalized so ``a/b=c`` will not match ``a//b``"
" either."
msgstr ""

#: ../../path-resolution.rst:624 22e480599402449ca27facd792ca3ad8
msgid ""
"Parts of file and directory names can match as well. "
"``/newProject/con:/new=old`` will match ``/newProject/contract.sol`` and "
"remap it to ``oldProject/contract.sol``."
msgstr ""

#: ../../path-resolution.rst:628 d3843bcd92914f0fa53136540c73da37
msgid "**At most one remapping is applied to a single import.**"
msgstr ""

#: ../../path-resolution.rst:630 edab5a8e81e64c1da18ef4d54799e9d9
msgid ""
"If multiple remappings match the same source unit name, the one with the "
"longest matching prefix is chosen."
msgstr ""

#: ../../path-resolution.rst:632 6d471b0abebf4f509add2c8adc2d8569
msgid "If prefixes are identical, the one specified last wins."
msgstr ""

#: ../../path-resolution.rst:633 675b3e7e72184a90a4d66766902b248d
msgid ""
"Remappings do not work on other remappings. For example ``a=b b=c c=d`` "
"will not result in ``a`` being remapped to ``d``."
msgstr ""

#: ../../path-resolution.rst:636 a014edc1aa464d248429a407e9ab078d
msgid "**Prefix cannot be empty but context and target are optional.**"
msgstr ""

#: ../../path-resolution.rst:638 3c631da1dbe34f24bef9a1a93a1f28b4
msgid ""
"If ``target`` is the empty string, ``prefix`` is simply removed from "
"import paths."
msgstr ""

#: ../../path-resolution.rst:639 e10f2f5a66f548ed9304fc5d02eb8985
msgid ""
"Empty ``context`` means that the remapping applies to all imports in all "
"source units."
msgstr ""

#: ../../path-resolution.rst:644 8b3c6d6a62df42d99cc69be24b74fd24
msgid "Using URLs in imports"
msgstr ""

#: ../../path-resolution.rst:646 4da90146fc3148c2a3d0a7c74387c271
msgid ""
"Most URL prefixes such as ``https://`` or ``data://`` have no special "
"meaning in import paths. The only exception is ``file://`` which is "
"stripped from source unit names by the Host Filesystem Loader."
msgstr ""

#: ../../path-resolution.rst:650 749bdfc176584eefb265228f0b9ca8b8
msgid ""
"When compiling locally you can use import remapping to replace the "
"protocol and domain part with a local path:"
msgstr ""

#: ../../path-resolution.rst:657 1ca0b23338514882bad632590e241116
msgid ""
"Note the leading ``:``, which is necessary when the remapping context is "
"empty. Otherwise the ``https:`` part would be interpreted by the compiler"
" as the context."
msgstr ""

